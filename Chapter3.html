<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.8.1: http://docutils.sourceforge.net/" />
<title>Chapter 3: The Structure and Interpretation of Computer Programs</title>
<link rel="stylesheet" href="css/lectures.css" type="text/css" />

        <script src="js/jsMath/easy/load.js"></script>
        <link href="css/prettify.css" type="text/css" rel="stylesheet" />
        <script type="text/javascript" src="css/prettify.js"></script></head>
<body onload="prettyPrint();">
<div class="document" id="chapter-3-the-structure-and-interpretation-of-computer-programs">
<h1 class="title">Chapter 3: The Structure and Interpretation of Computer Programs</h1>
<!-- These notes have been placed in the public domain under the license -->
<!-- Creative Commons Attribution-ShareAlike 3.0 -->
<!-- http://creativecommons.org/licenses/by-sa/3.0/ -->
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="auto-toc simple">
<li><a class="reference internal" href="#introduction" id="id4">3.1&nbsp;&nbsp;&nbsp;Introduction</a><ul class="auto-toc">
<li><a class="reference internal" href="#programming-languages" id="id5">3.1.1&nbsp;&nbsp;&nbsp;Programming Languages</a></li>
</ul>
</li>
<li><a class="reference internal" href="#functions-and-the-processes-they-generate" id="id6">3.2&nbsp;&nbsp;&nbsp;Functions and the Processes They Generate</a><ul class="auto-toc">
<li><a class="reference internal" href="#recursive-functions" id="id7">3.2.1&nbsp;&nbsp;&nbsp;Recursive Functions</a></li>
<li><a class="reference internal" href="#the-anatomy-of-recursive-functions" id="id8">3.2.2&nbsp;&nbsp;&nbsp;The Anatomy of Recursive Functions</a></li>
<li><a class="reference internal" href="#tree-recursion" id="id9">3.2.3&nbsp;&nbsp;&nbsp;Tree Recursion</a></li>
<li><a class="reference internal" href="#example-counting-change" id="id10">3.2.4&nbsp;&nbsp;&nbsp;Example: Counting Change</a></li>
<li><a class="reference internal" href="#orders-of-growth" id="id11">3.2.5&nbsp;&nbsp;&nbsp;Orders of Growth</a></li>
<li><a class="reference internal" href="#example-exponentiation" id="id12">3.2.6&nbsp;&nbsp;&nbsp;Example: Exponentiation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#recursive-data-structures" id="id13">3.3&nbsp;&nbsp;&nbsp;Recursive Data Structures</a><ul class="auto-toc">
<li><a class="reference internal" href="#processing-recursive-lists" id="id14">3.3.1&nbsp;&nbsp;&nbsp;Processing Recursive Lists</a></li>
<li><a class="reference internal" href="#hierarchical-structures" id="id15">3.3.2&nbsp;&nbsp;&nbsp;Hierarchical Structures</a></li>
<li><a class="reference internal" href="#sets" id="id16">3.3.3&nbsp;&nbsp;&nbsp;Sets</a></li>
</ul>
</li>
<li><a class="reference internal" href="#exceptions" id="id17">3.4&nbsp;&nbsp;&nbsp;Exceptions</a><ul class="auto-toc">
<li><a class="reference internal" href="#exception-objects" id="id18">3.4.1&nbsp;&nbsp;&nbsp;Exception Objects</a></li>
</ul>
</li>
<li><a class="reference internal" href="#interpreters-for-languages-with-combination" id="id19">3.5&nbsp;&nbsp;&nbsp;Interpreters for Languages with Combination</a><ul class="auto-toc">
<li><a class="reference internal" href="#calculator" id="id20">3.5.1&nbsp;&nbsp;&nbsp;Calculator</a></li>
<li><a class="reference internal" href="#parsing" id="id21">3.5.2&nbsp;&nbsp;&nbsp;Parsing</a></li>
</ul>
</li>
<li><a class="reference internal" href="#interpreters-for-languages-with-abstraction" id="id22">3.6&nbsp;&nbsp;&nbsp;Interpreters for Languages with Abstraction</a><ul class="auto-toc">
<li><a class="reference internal" href="#the-scheme-language" id="id23">3.6.1&nbsp;&nbsp;&nbsp;The Scheme Language</a></li>
<li><a class="reference internal" href="#the-logo-language" id="id24">3.6.2&nbsp;&nbsp;&nbsp;The Logo Language</a></li>
<li><a class="reference internal" href="#structure" id="id25">3.6.3&nbsp;&nbsp;&nbsp;Structure</a></li>
<li><a class="reference internal" href="#environments" id="id26">3.6.4&nbsp;&nbsp;&nbsp;Environments</a></li>
<li><a class="reference internal" href="#data-as-programs" id="id27">3.6.5&nbsp;&nbsp;&nbsp;Data as Programs</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="introduction">
<h1><a class="toc-backref" href="#id4">3.1&nbsp;&nbsp;&nbsp;Introduction</a></h1>
<p>Chapters 1 and 2 describe the close connection between two fundamental
elements of programming: functions and data.  We saw how functions can be
manipulated as data using higher-order functions. We also saw how data can be
endowed with behavior using message passing and an object system. We have also
studied techniques for organizing large programs, such as functional
abstraction, data abstraction, class inheritance, and generic functions. These
core concepts constitute a strong foundation upon which to build modular,
maintainable, and extensible programs.</p>
<p>This chapter focuses on the third fundamental element of programming: programs
themselves. A Python program is just a collection of text.  Only through the
process of interpretation do we perform any meaningful computation based on
that text.  A programming language like Python is useful because we can define
an <em>interpreter</em>, a program that carries out Python's evaluation and execution
procedures.  It is no exaggeration to regard this as the most fundamental idea
in programming, that an interpreter, which determines the meaning of
expressions in a programming language, is just another program.</p>
<p>To appreciate this point is to change our images of ourselves as programmers.
We come to see ourselves as designers of languages, rather than only users of
languages designed by others.</p>
<div class="section" id="programming-languages">
<h2><a class="toc-backref" href="#id5">3.1.1&nbsp;&nbsp;&nbsp;Programming Languages</a></h2>
<p>In fact, we can regard many programs as interpreters for some language. For
example, the constraint propagator from the previous chapter has its own
primitives and means of combination. The constraint language was quite
specialized: it provided a declarative method for describing a certain class of
mathematical relations, not a fully general language for describing
computation. While we have been designing languages of a sort already, the
material of this chapter will greatly expand the range of languages we can
interpret.</p>
<p>Programming languages vary widely in their syntactic structures, features, and
domain of application. Among general purpose programming languages, the
constructs of function definition and function application are pervasive.  On
the other hand, powerful languages exist that do not include an object system,
higher-order functions, or even control constructs like <tt class="docutils literal">while</tt> and <tt class="docutils literal">for</tt>
statements. To illustrate just how different languages can be, we will
introduce <a class="reference external" href="http://www.cs.berkeley.edu/~bh/logo.html">Logo</a> as an example of a
powerful and expressive programming language that includes very few advanced
features.</p>
<p>In this chapter, we study the design of interpreters and the computational
processes that they create when executing programs. The prospect of designing
an interpreter for a general programming language may seem daunting. After all,
interpreters are programs that can carry out any possible computation,
depending on their input.  However, typical interpreters have an elegant common
structure: two mutually recursive functions.  The first evaluates expressions
in environments; the second applies functions to arguments.</p>
<p>These functions are <em>recursive</em> in that they are defined in terms of each
other: applying a function requires evaluating the expressions in its body,
while evaluating an expression may involve applying one or more functions.  The
next two sections of this chapter focus on recursive functions and data
structures, which will prove essential to understanding the design of an
interpreter. The end of the chapter focuses on two new languages and the task
of implementing interpreters for them.</p>
</div>
</div>
<div class="section" id="functions-and-the-processes-they-generate">
<h1><a class="toc-backref" href="#id6">3.2&nbsp;&nbsp;&nbsp;Functions and the Processes They Generate</a></h1>
<p>A function is a pattern for the <em>local evolution</em> of a computational process.
It specifies how each stage of the process is built upon the previous stage.
We would like to be able to make statements about the overall behavior of a
process whose local evolution has been specified by one or more functions. This
analysis is very difficult to do in general, but we can at least try to
describe some typical patterns of process evolution.</p>
<p>In this section we will examine some common &quot;shapes&quot; for processes generated by
simple functions. We will also investigate the rates at which these processes
consume the important computational resources of time and space.</p>
<div class="section" id="recursive-functions">
<h2><a class="toc-backref" href="#id7">3.2.1&nbsp;&nbsp;&nbsp;Recursive Functions</a></h2>
<p>A function is called <em>recursive</em> if the body of that function calls the
function itself, either directly or indirectly. That is, the process of
executing the body of a recursive function may in turn require applying that
function again.  Recursive functions do not require any special syntax in
Python, but they do require some care to define correctly.</p>
<p>As an introduction to recursive functions, we begin with the task of converting
an English word into its Pig Latin equivalent.  Pig Latin is a secret language:
one that applies a simple, deterministic transformation to each word that veils
the meaning of the word.  Thomas Jefferson was supposedly an <a class="reference external" href="http://goo.gl/Cwysz">early adopter</a>.  The Pig Latin equivalent of an English word moves the
initial consonant cluster (which may be empty) from the beginning of the word
to the end and follows it by the &quot;-ay&quot; vowel.  Hence, the word &quot;pun&quot; becomes
&quot;unpay&quot;, &quot;stout&quot; becomes &quot;outstay&quot;, and &quot;all&quot; becomes &quot;allay&quot;.</p>
<pre class="doctest-block">
&gt;&gt;&gt; def pig_latin(w):
        &quot;&quot;&quot;Return the Pig Latin equivalent of English word w.&quot;&quot;&quot;
        if starts_with_a_vowel(w):
            return w + 'ay'
        return pig_latin(w[1:] + w[0])
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; def starts_with_a_vowel(w):
        &quot;&quot;&quot;Return whether w begins with a vowel.&quot;&quot;&quot;
        return w[0].lower() in 'aeiou'
</pre>
<p>The idea behind this definition is that the Pig Latin variant of a string that
starts with a consonant is the same as the Pig Latin variant of another string:
that which is created by moving the first letter to the end.  Hence, the Pig
Latin word for &quot;sending&quot; is the same as for &quot;endings&quot; (<em>endingsay</em>), and the Pig
Latin word for &quot;smother&quot; is the same as the Pig Latin word for &quot;mothers&quot;
(<em>othersmay</em>). Moreover, moving one consonant from the beginning of the word to
the end results in a simpler problem with fewer initial consonants.  In the case
of &quot;sending&quot;, moving the &quot;s&quot; to the end gives a word that starts with a vowel,
and so our work is done.</p>
<p>This definition of <tt class="docutils literal">pig_latin</tt> is both complete and correct, even though the
<tt class="docutils literal">pig_latin</tt> function is called within its own body.</p>
<pre class="doctest-block">
&gt;&gt;&gt; pig_latin('pun')
'unpay'
</pre>
<p>The idea of being able to define a function in terms of itself may be
disturbing; it may seem unclear how such a &quot;circular&quot; definition could make
sense at all, much less specify a well-defined process to be carried out by a
computer.  We can, however, understand precisely how this recursive function
applies successfully using our environment model of computation. The
environment diagram and expression tree that depict the evaluation of
<tt class="docutils literal"><span class="pre">pig_latin('pun')</span></tt> appear below.</p>
<div class="figure">
<img alt="img/pig_latin.png" src="img/pig_latin.png" />
</div>
<p>The steps of the Python evaluation procedures that produce this result are:</p>
<ol class="arabic simple">
<li>The <tt class="docutils literal">def</tt> statement for <tt class="docutils literal">pig_latin</tt> is executed, which</li>
</ol>
<blockquote>
<ol class="upperalpha simple">
<li>Creates a new <em>pig_latin</em> function object with the stated body, and</li>
<li>Binds the name <tt class="docutils literal">pig_latin</tt> to that function in the current (global)
frame</li>
</ol>
</blockquote>
<ol class="arabic simple" start="2">
<li>The <tt class="docutils literal">def</tt> statement for <tt class="docutils literal">starts_with_a_vowel</tt> is executed similarly</li>
<li>The call expression <tt class="docutils literal"><span class="pre">pig_latin('pun')</span></tt> is evaluated by</li>
</ol>
<blockquote>
<ol class="upperalpha simple">
<li>Evaluating the operator and operand sub-expressions by</li>
</ol>
<blockquote>
<ol class="upperroman simple">
<li>Looking up the name <tt class="docutils literal">pig_latin</tt> that is bound to the <em>pig_latin</em>
function</li>
<li>Evaluating the operand string literal to the string object <tt class="docutils literal">'pun'</tt></li>
</ol>
</blockquote>
<ol class="upperalpha simple" start="2">
<li>Applying the function <em>pig_latin</em> to the argument <tt class="docutils literal">'pun'</tt> by</li>
</ol>
<blockquote>
<ol class="upperroman simple">
<li>Adding a local frame that extends the global frame</li>
<li>Binding the formal parameter <tt class="docutils literal">w</tt> to the argument <tt class="docutils literal">'pun'</tt> in that
frame</li>
<li>Executing the body of <em>pig_latin</em> in the environment that starts with
that frame:</li>
</ol>
<blockquote>
<ol class="loweralpha simple">
<li>The initial conditional statement has no effect, because the header
expression evaluates to <tt class="docutils literal">False</tt>.</li>
<li>The final return expression <tt class="docutils literal">pig_latin(w[1:] + w[0])</tt> is evaluated
by</li>
</ol>
<blockquote>
<ol class="arabic simple">
<li>Looking up the name <tt class="docutils literal">pig_latin</tt> that is bound to the
<em>pig_latin</em> function</li>
<li>Evaluating the operand expression to the string object <tt class="docutils literal">'unp'</tt></li>
<li>Applying <em>pig_latin</em> to the argument <tt class="docutils literal">'unp'</tt>, which returns the
desired result from the suite of the conditional statement in the
body of <em>pig_latin</em>.</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>As this example illustrates, a recursive function applies correctly, despite
its circular character.  The <em>pig_latin</em> function is applied twice, but with a
different argument each time.  Although the second call comes from the body of
<em>pig_latin</em> itself, looking up that function by name succeeds because the name
<tt class="docutils literal">pig_latin</tt> is bound in the environment before its body is executed.</p>
<p>This example also illustrates how Python's recursive evaluation procedure can
interact with a recursive function to evolve a complex computational process
with many nested steps, even though the function definition may itself contain
very few lines of code.</p>
</div>
<div class="section" id="the-anatomy-of-recursive-functions">
<h2><a class="toc-backref" href="#id8">3.2.2&nbsp;&nbsp;&nbsp;The Anatomy of Recursive Functions</a></h2>
<p>A common pattern can be found in the body of many recursive functions.  The
body begins with a <em>base case</em>, a conditional statement that defines the
behavior of the function for the inputs that are simplest to process.  In the
case of <tt class="docutils literal">pig_latin</tt>, the base case occurs for any argument that starts with a
vowel.  In this case, there is no work left to be done but return the argument
with &quot;ay&quot; added to the end. Some recursive functions will have multiple base
cases.</p>
<p>The base cases are then followed by one or more <em>recursive calls</em>.  Recursive
calls require a certain character: they must simplify the original problem.  In
the case of <tt class="docutils literal">pig_latin</tt>, the more initial consonants in <tt class="docutils literal">w</tt>, the more work
there is left to do. In the recursive call, <tt class="docutils literal">pig_latin(w[1:] + w[0])</tt>, we call
<tt class="docutils literal">pig_latin</tt> on a word that has one fewer initial consonant -- a simpler
problem.  Each successive call to <tt class="docutils literal">pig_latin</tt> will be simpler still until
the base case is reached: a word with no initial consonants.</p>
<p>Recursive functions express computation by simplifying problems incrementally.
They often operate on problems in a different way than the iterative
approaches that we have used in the past. Consider a function <tt class="docutils literal">fact</tt> to
compute <tt class="docutils literal">n</tt> factorial, where for example <tt class="docutils literal">fact(4)</tt> computes \(4! = 4
\cdot 3 \cdot 2 \cdot 1 = 24\).</p>
<p>A natural implementation using a <tt class="docutils literal">while</tt> statement accumulates the total by
multiplying together each positive integer up to <tt class="docutils literal">n</tt>.</p>
<pre class="doctest-block">
&gt;&gt;&gt; def fact_iter(n):
        total, k = 1, 1
        while k &lt;= n:
            total, k = total * k, k + 1
        return total
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; fact_iter(4)
24
</pre>
<p>On the other hand, a recursive implementation of factorial can express
<tt class="docutils literal">fact(n)</tt> in terms of <tt class="docutils literal"><span class="pre">fact(n-1)</span></tt>, a simpler problem.  The base case of the
recursion is the simplest form of the problem: <tt class="docutils literal">fact(1)</tt> is <tt class="docutils literal">1</tt>.</p>
<pre class="doctest-block">
&gt;&gt;&gt; def fact(n):
        if n == 1:
            return 1
        return n * fact(n-1)
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; fact(4)
24
</pre>
<p>The correctness of this function is easy to verify from the standard definition
of the mathematical function for factorial:</p>
\[\begin{array}{l l}
(n-1)! &=     (n-1) \cdot (n-2) \cdot \dots \cdot 1 \\
n!     &= n \cdot (n-1) \cdot (n-2) \cdot \dots \cdot 1 \\
n!     &= n \cdot (n-1)!
\end{array}\]<p>These two factorial functions differ conceptually.  The iterative function
constructs the result from the base case of 1 to the final total by
successively multiplying in each term.  The recursive function, on the other
hand, constructs the result directly from the final term, <tt class="docutils literal">n</tt>,  and the
result of the simpler problem, <tt class="docutils literal"><span class="pre">fact(n-1)</span></tt>.</p>
<p>As the recursion &quot;unwinds&quot; through successive applications of the <em>fact</em>
function to simpler and simpler problem instances, the result is eventually
built starting from the base case.  The diagram below shows how the recursion
ends by passing the argument <tt class="docutils literal">1</tt> to <tt class="docutils literal">fact</tt>, and how the result of each call
depends on the next until the base case is reached.</p>
<div class="figure">
<img alt="img/fact.png" src="img/fact.png" />
</div>
<p>While we can unwind the recursion using our model of computation, it is often
clearer to think about recursive calls as functional abstractions.  That is, we
should not care about how <tt class="docutils literal"><span class="pre">fact(n-1)</span></tt> is implemented in the body of <tt class="docutils literal">fact</tt>;
we should simply trust that it computes the factorial of <tt class="docutils literal"><span class="pre">n-1</span></tt>.  Treating a
recursive call as a functional abstraction has been called a <em>recursive leap
of faith</em>. We define a function in terms of itself, but simply trust that the
simpler cases will work correctly when verifying the correctness of the
function. In this example, we trust that <tt class="docutils literal"><span class="pre">fact(n-1)</span></tt> will correctly compute
<tt class="docutils literal"><span class="pre">(n-1)!</span></tt>; we must only check that <tt class="docutils literal">n!</tt> is computed correctly if this
assumption holds. In this way, verifying the correctness of a recursive function
is a form of proof by induction.</p>
<p>The functions <em>fact_iter</em> and <em>fact</em> also differ because the former must
introduce two additional names, <tt class="docutils literal">total</tt> and <tt class="docutils literal">k</tt>, that are not required in
the recursive implementation.  In general, iterative functions must maintain
some local state that changes throughout the course of computation.  At any
point in the iteration, that state characterizes the result of completed work
and the amount of work remaining.  For example, when <tt class="docutils literal">k</tt> is <tt class="docutils literal">3</tt> and total
is <tt class="docutils literal">2</tt>, there are still two terms remaining to be processed, <tt class="docutils literal">3</tt> and <tt class="docutils literal">4</tt>.
On the other hand, <em>fact</em> is characterized by its single argument <tt class="docutils literal">n</tt>. The
state of the computation is entirely contained within the structure of the
expression tree, which has return values that take the role of <tt class="docutils literal">total</tt>, and
binds <tt class="docutils literal">n</tt> to different values in different frames rather than explicitly
tracking <tt class="docutils literal">k</tt>.</p>
<p>Recursive functions can rely more heavily on the interpreter itself, by storing
the state of the computation as part of the expression tree and environment,
rather than explicitly using names in the local frame. For this reason,
recursive functions are often easier to define, because we do not need to try
to determine the local state that must be maintained across iterations. On the
other hand, learning to recognize the computational processes evolved by
recursive functions can require some practice.</p>
</div>
<div class="section" id="tree-recursion">
<h2><a class="toc-backref" href="#id9">3.2.3&nbsp;&nbsp;&nbsp;Tree Recursion</a></h2>
<p>Another common pattern of computation is called tree recursion. As an example,
consider computing the sequence of Fibonacci numbers, in which each number is
the sum of the preceding two.</p>
<pre class="doctest-block">
&gt;&gt;&gt; def fib(n):
        if n == 1:
            return 0
        if n == 2:
            return 1
        return fib(n-2) + fib(n-1)
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; fib(6)
5
</pre>
<p>This recursive definition is tremendously appealing relative to our previous
attempts: it exactly mirrors the familiar definition of Fibonacci numbers.
Consider the pattern of computation that results from evaluating <tt class="docutils literal">fib(6)</tt>,
shown below.  To compute <tt class="docutils literal">fib(6)</tt>, we compute <tt class="docutils literal">fib(5)</tt> and <tt class="docutils literal">fib(4)</tt>.  To
compute <tt class="docutils literal">fib(5)</tt>, we compute <tt class="docutils literal">fib(4)</tt> and <tt class="docutils literal">fib(3)</tt>.  In general, the
evolved process looks like a tree (the diagram below is not a full expression
tree, but instead a simplified depiction of the process; a full expression tree
would have the same general structure). Each blue dot indicates a completed
computation of a Fibonacci number in the traversal of this tree.</p>
<div class="figure">
<img alt="img/fib.png" src="img/fib.png" />
</div>
<p>Functions that call themselves multiple times in this way are said to be
<em>tree recursive</em>.  This function is instructive as a prototypical tree
recursion, but it is a terrible way to compute Fibonacci numbers because it
does so much redundant computation. Notice that the entire computation of
<tt class="docutils literal">fib(4)</tt> -- almost half the work -- is duplicated. In fact, it is not hard to
show that the number of times the function will compute <tt class="docutils literal">fib(1)</tt> or
<tt class="docutils literal">fib(2)</tt> (the number of leaves in the tree, in general) is precisely
<tt class="docutils literal">fib(n+1)</tt>. To get an idea of how bad this is, one can show that the value of
<tt class="docutils literal">fib(n)</tt> grows exponentially with <tt class="docutils literal">n</tt>.  Thus, the process uses a number of
steps that grows exponentially with the input.</p>
<p>We have already seen an iterative implementation of Fibonacci numbers, repeated
here for convenience.</p>
<pre class="doctest-block">
&gt;&gt;&gt; def fib_iter(n):
        prev, curr = 1, 0  # curr is the first Fibonacci number.
        for _ in range(n-1):
             prev, curr = curr, prev + curr
        return curr
</pre>
<p>The state that we must maintain in this case consists of the current and
previous Fibonacci numbers.  Implicitly the <tt class="docutils literal">for</tt> statement also keeps track of
the iteration count. This definition does not reflect the standard mathematical
definition of Fibonacci numbers as clearly as the recursive approach.  However,
the amount of computation required in the iterative implementation is only
linear in <tt class="docutils literal">n</tt>, rather than exponential. Even for small values of <tt class="docutils literal">n</tt>, this
difference can be enormous.</p>
<p>One should not conclude from this difference that tree-recursive processes are
useless. When we consider processes that operate on hierarchically structured
data rather than numbers, we will find that tree recursion is a natural and
powerful tool. Furthermore, tree-recursive processes can often be made more
efficient.</p>
<p><strong>Memoization.</strong> A powerful technique for increasing the efficiency of recursive
functions that repeat computation is called <em>memoization</em>.  A memoized function
will store the return value for any arguments it has previously received.
A second call to <tt class="docutils literal">fib(4)</tt> would not evolve the same complex process as
the first, but instead would immediately return the stored result computed by
the first call.</p>
<p>Memoization can be expressed naturally as a higher-order function, which
can also be used as a decorator. The definition below creates a <em>cache</em> of
previously computed results, indexed by the arguments from which they were
computed. The use of a dictionary will require that the argument to the
memoized function be immutable in this implementation.</p>
<pre class="doctest-block">
&gt;&gt;&gt; def memo(f):
        &quot;&quot;&quot;Return a memoized version of single-argument function f.&quot;&quot;&quot;
        cache = {}
        def memoized(n):
            if n not in cache:
                cache[n] = f(n)
            return cache[n]
        return memoized
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; fib = memo(fib)
&gt;&gt;&gt; fib(40)
63245986
</pre>
<p>The amount of computation time saved by memoization in this case is
substantial. The memoized, recursive <em>fib</em> function and the iterative
<em>fib_iter</em> function both require an amount of time to compute that is only a
linear function of their input <tt class="docutils literal">n</tt>.  To compute <tt class="docutils literal">fib(40)</tt>, the body of
<tt class="docutils literal">fib</tt> is executed 40 times, rather than 102,334,155 times in the unmemoized
recursive case.</p>
<p><strong>Space.</strong> To understand the space requirements of a function, we must specify
generally how memory is used, preserved, and reclaimed in our environment model
of computation. In evaluating an expression, we must preserve all <em>active</em>
environments and all values and frames referenced by those environments.  An
environment is active if it provides the evaluation context for some expression
in the current branch of the expression tree.</p>
<p>For example, when evaluating <tt class="docutils literal">fib</tt>, the interpreter proceeds to compute each
value in the order shown previously, traversing the structure of the tree.  To
do so, it only needs to keep track of those nodes that are above the current node in
the tree at any point in the computation. The memory used to evaluate the rest
of the branches can be reclaimed because it cannot affect future computation.
In general, the space required for tree-recursive functions will be
proportional to the maximum depth of the tree.</p>
<p>The diagram below depicts the environment and expression tree generated by
evaluating <tt class="docutils literal">fib(3)</tt>.  In the process of evaluating the return expression for
the initial application of <tt class="docutils literal">fib</tt>, the expression <tt class="docutils literal"><span class="pre">fib(n-2)</span></tt> is evaluated,
yielding a value of <tt class="docutils literal">0</tt>. Once this value is computed, the corresponding
environment frame (grayed out) is no longer needed: it is not part of an active
environment. Thus, a well-designed interpreter can reclaim the memory that was
used to store this frame. On the other hand, if the interpreter is currently
evaluating <tt class="docutils literal"><span class="pre">fib(n-1)</span></tt>, then the environment created by this application of
<tt class="docutils literal">fib</tt> (in which <tt class="docutils literal">n</tt> is <tt class="docutils literal">2</tt>) is active. In turn, the environment
originally created to apply <tt class="docutils literal">fib</tt> to <tt class="docutils literal">3</tt> is active because its value has not
yet been successfully computed.</p>
<div class="figure">
<img alt="img/fib_env.png" src="img/fib_env.png" />
</div>
<p>In the case of <tt class="docutils literal">memo</tt>, the environment associated with the function it
returns (which contains <tt class="docutils literal">cache</tt>) must be preserved as long as some name is
bound to that function in an active environment. The number of entries in the
<tt class="docutils literal">cache</tt> dictionary grows linearly with the number of unique arguments passed
to <tt class="docutils literal">fib</tt>, which scales linearly with the input. On the other hand, the
iterative implementation requires only two numbers to be tracked during
computation: <tt class="docutils literal">prev</tt> and <tt class="docutils literal">curr</tt>, giving it a constant size.</p>
<p>Memoization exemplifies a common pattern in programming that computation
time can often be decreased at the expense of increased use of space, or vis
versa.</p>
</div>
<div class="section" id="example-counting-change">
<h2><a class="toc-backref" href="#id10">3.2.4&nbsp;&nbsp;&nbsp;Example: Counting Change</a></h2>
<p>Consider the following problem: How many different ways can we make change of
$1.00, given half-dollars, quarters, dimes, nickels, and pennies? More
generally, can we write a function to compute the number of ways to change any
given amount of money using any set of currency denominations?</p>
<p>This problem has a simple solution as a recursive function. Suppose we think of
the types of coins available as arranged in some order, say from most to least
valuable.</p>
<p>The number of ways to change an amount <tt class="docutils literal">a</tt> using <tt class="docutils literal">n</tt> kinds of coins equals</p>
<ol class="arabic simple">
<li>the number of ways to change <tt class="docutils literal">a</tt> using all but the first kind of coin,
plus</li>
<li>the number of ways to change the smaller amount <tt class="docutils literal">a - d</tt> using all <tt class="docutils literal">n</tt>
kinds of coins, where <tt class="docutils literal">d</tt> is the denomination of the first kind of coin.</li>
</ol>
<p>To see why this is true, observe that the ways to make change can be divided
into two groups: those that do not use any of the first kind of coin, and those
that do. Therefore, the total number of ways to make change for some amount is
equal to the number of ways to make change for the amount without using any of
the first kind of coin, plus the number of ways to make change assuming that we
do use the first kind of coin at least once. But the latter number is equal to
the number of ways to make change for the amount that remains after using a
coin of the first kind.</p>
<p>Thus, we can recursively reduce the problem of changing a given amount to the
problem of changing smaller amounts using fewer kinds of coins. Consider this
reduction rule carefully and convince yourself that we can use it to describe
an algorithm if we specify the following base cases:</p>
<ol class="arabic simple">
<li>If <tt class="docutils literal">a</tt> is exactly <tt class="docutils literal">0</tt>, we should count that as <tt class="docutils literal">1</tt> way to make change.</li>
<li>If <tt class="docutils literal">a</tt> is less than <tt class="docutils literal">0</tt>, we should count that as <tt class="docutils literal">0</tt> ways to make change.</li>
<li>If <tt class="docutils literal">n</tt> is <tt class="docutils literal">0</tt>, we should count that as <tt class="docutils literal">0</tt> ways to make change.</li>
</ol>
<p>We can easily translate this description into a recursive function:</p>
<pre class="doctest-block">
&gt;&gt;&gt; def count_change(a, kinds=(50, 25, 10, 5, 1)):
        &quot;&quot;&quot;Return the number of ways to change amount a using coin kinds.&quot;&quot;&quot;
        if a == 0:
            return 1
        if a &lt; 0 or len(kinds) == 0:
            return 0
        d = kinds[0]
        return count_change(a, kinds[1:]) + count_change(a - d, kinds)
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; count_change(100)
292
</pre>
<p>The <tt class="docutils literal">count_change</tt> function generates a tree-recursive process with
redundancies similar to those in our first implementation of <tt class="docutils literal">fib</tt>. It will
take quite a while for that <tt class="docutils literal">292</tt> to be computed, unless we memoize the
function. On the other hand, it is not obvious how to design an iterative
algorithm for computing the result, and we leave this problem as a challenge.</p>
</div>
<div class="section" id="orders-of-growth">
<h2><a class="toc-backref" href="#id11">3.2.5&nbsp;&nbsp;&nbsp;Orders of Growth</a></h2>
<p>The previous examples illustrate that processes can differ considerably in the
rates at which they consume the computational resources of space and time. One
convenient way to describe this difference is to use the notion of <em>order of
growth</em> to obtain a coarse measure of the resources required by a process as
the inputs become larger.</p>
<p>Let \(n\) be a parameter that measures the size of the problem, and let
\(R(n)\) be the amount of resources the process requires for a problem of
size \(n\). In our previous examples we took \(n\) to be the number for
which a given function is to be computed, but there are other possibilities. For
instance, if our goal is to compute an approximation to the square root of a
number, we might take \(n\) to be the number of digits of accuracy
required.  In general there are a number of properties of the problem with
respect to which it will be desirable to analyze a given process. Similarly,
\(R(n)\) might measure the amount of memory used, the number of elementary
machine operations performed, and so on. In computers that do only a fixed
number of operations at a time, the time required to evaluate an expression
will be proportional to the number of elementary machine operations performed
in the process of evaluation.</p>
<p>We say that \(R(n)\) has order of growth \(\Theta(f(n))\), written
\(R(n) = \Theta(f(n))\) (pronounced &quot;theta of \(f(n)\)&quot;), if there are
positive constants \(k_1\) and \(k_2\) independent of \(n\) such
that</p>
\[k_1 \cdot f(n) \leq R(n) \leq k_2 \cdot f(n)\]<p>for any sufficiently large value of \(n\). In other words, for large
\(n\), the value \(R(n)\) is sandwiched between two values that both
scale with \(f(n)\):</p>
<ul class="simple">
<li>A lower bound \(k_1 \cdot f(n)\) and</li>
<li>An upper bound \(k_2 \cdot f(n)\)</li>
</ul>
<p>For instance, the number of steps to compute \(n!\) grows proportionally to
the input \(n\). Thus, the steps required for this process grows as
\(\Theta(n)\).  We also saw that the space required for the recursive
implementation <tt class="docutils literal">fact</tt> grows as \(\Theta(n)\). By contrast, the iterative
implementation <tt class="docutils literal">fact_iter</tt> takes a similar number of steps, but the space it
requires stays constant.  In this case, we say that the space grows as
\(\Theta(1)\).</p>
<p>The number of steps in our tree-recursive Fibonacci computation <tt class="docutils literal">fib</tt> grows
exponentially in its input \(n\). In particular, one can show that
the nth Fibonacci number is the closest integer to</p>
\[\frac{\phi^{n-2}}{\sqrt{5}}\]<p>where \(\phi\) is the golden ratio:</p>
\[\phi = \frac{1 + \sqrt{5}}{2} \approx 1.6180\]<p>We also stated that the number of steps scales with the resulting value, and so
the tree-recursive process requires \(\Theta(\phi^n)\) steps, a function
that grows exponentially with \(n\).</p>
<p>Orders of growth provide only a crude description of the behavior of a process.
For example, a process requiring \(n^2\) steps and a process requiring
\(1000 \cdot n^2\) steps and a process requiring \(3 \cdot n^2 + 10
\cdot n + 17\) steps all have \(\Theta(n^2)\) order of growth. There are
certainly cases in which an order of growth analysis is too coarse a method for
deciding between two possible implementations of a function.</p>
<p>However, order of growth provides a useful indication of how we may expect the
behavior of the process to change as we change the size of the problem. For a
\(\Theta(n)\) (linear) process, doubling the size will roughly double the
amount of resources used. For an exponential process, each increment in problem
size will multiply the resource utilization by a constant factor. The next
example examines an algorithm whose order of growth is logarithmic, so that
doubling the problem size increases the resource requirement by only a constant
amount.</p>
</div>
<div class="section" id="example-exponentiation">
<h2><a class="toc-backref" href="#id12">3.2.6&nbsp;&nbsp;&nbsp;Example: Exponentiation</a></h2>
<p>Consider the problem of computing the exponential of a given number. We would
like a function that takes as arguments a base <tt class="docutils literal">b</tt> and a positive integer
exponent <tt class="docutils literal">n</tt> and computes \(b^n\). One way to do this is via the recursive
definition</p>
\[\begin{array}{l l}
b^n &= b \cdot b^{n-1} \\
b^0 &= 1
\end{array}\]<p>which translates readily into the recursive function</p>
<pre class="doctest-block">
&gt;&gt;&gt; def exp(b, n):
        if n == 0:
            return 1
        return b * exp(b, n-1)
</pre>
<p>This is a linear recursive process that requires \(\Theta(n)\) steps and
\(\Theta(n)\) space. Just as with factorial, we can readily formulate an
equivalent linear iteration that requires a similar number of steps but constant
space.</p>
<pre class="doctest-block">
&gt;&gt;&gt; def exp_iter(b, n):
        result = 1
        for _ in range(n):
            result = result * b
        return result
</pre>
<p>We can compute exponentials in fewer steps by using successive squaring. For
instance, rather than computing \(b^8\) as</p>
\[b \cdot (b \cdot (b \cdot (b \cdot (b \cdot (b \cdot (b \cdot b))))))\]<p>we can compute it using three multiplications:</p>
\[\begin{array}{l l}
b^2 &= b \cdot b \\
b^4 &= b^2 \cdot b^2 \\
b^8 &= b^4 \cdot b^4
\end{array}\]<p>This method works fine for exponents that are powers of <tt class="docutils literal">2</tt>. We can also take
advantage of successive squaring in computing exponentials in general if we use
the recursive rule</p>
\[b^n = \left\{\begin{array}{l l} (b^{\frac{1}{2} n})^2 & \mbox{if $n$ is even} \\
                    b \cdot b^{n-1}     & \mbox{if $n$ is odd}
                    \end{array} \right.\]<p>We can express this method as a recursive function as well:</p>
<pre class="doctest-block">
&gt;&gt;&gt; def square(x):
        return x*x
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; def fast_exp(b, n):
        if n == 0:
            return 1
        if n % 2 == 0:
            return square(fast_exp(b, n//2))
        else:
            return b * fast_exp(b, n-1)
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; fast_exp(2, 100)
1267650600228229401496703205376
</pre>
<p>The process evolved by <tt class="docutils literal">fast_exp</tt> grows logarithmically with <tt class="docutils literal">n</tt> in both
space and number of steps. To see this, observe that computing \(b^{2n}\)
using <tt class="docutils literal">fast_exp</tt> requires only one more multiplication than computing
\(b^n\). The size of the exponent we can compute therefore doubles
(approximately) with every new multiplication we are allowed. Thus, the number
of multiplications required for an exponent of <tt class="docutils literal">n</tt> grows about as fast as the
logarithm of <tt class="docutils literal">n</tt> base <tt class="docutils literal">2</tt>. The process has \(\Theta(\log n)\) growth.
The difference between \(\Theta(\log n)\) growth and \(\Theta(n)\)
growth becomes striking as \(n\) becomes large. For example, <tt class="docutils literal">fast_exp</tt>
for <tt class="docutils literal">n</tt> of <tt class="docutils literal">1000</tt> requires only <tt class="docutils literal">14</tt> multiplications instead of <tt class="docutils literal">1000</tt>.</p>
</div>
</div>
<div class="section" id="recursive-data-structures">
<h1><a class="toc-backref" href="#id13">3.3&nbsp;&nbsp;&nbsp;Recursive Data Structures</a></h1>
<p>In Chapter 2, we introduced the notion of a pair as a primitive mechanism for
glueing together two objects into one.  We showed that a pair can be implemented
using a built-in tuple.  The <em>closure</em> property of pairs indicated that either
element of a pair could itself be a pair.</p>
<p>This closure property allowed us to implement the recursive list data
abstraction, which served as our first type of sequence. Recursive lists are
most naturally manipulated using recursive functions, as their name and
structure would suggest.  In this section, we discuss functions for creating
and manipulating recursive lists and other recursive data structures.</p>
<div class="section" id="processing-recursive-lists">
<h2><a class="toc-backref" href="#id14">3.3.1&nbsp;&nbsp;&nbsp;Processing Recursive Lists</a></h2>
<p>Recall that the recursive list abstract data type represented a list as a first
element and the rest of the list. We previously implemented recursive lists
using functions, but at this point we can re-implement them using a class.
Below, the length (<tt class="docutils literal">__len__</tt>) and element selection (<tt class="docutils literal">__getitem__</tt>)
functions are written recursively to demonstrate typical patterns for
processing recursive lists.</p>
<pre class="doctest-block">
&gt;&gt;&gt; class Rlist(object):
        &quot;&quot;&quot;A recursive list consisting of a first element and the rest.&quot;&quot;&quot;
        class EmptyList(object):
            def __len__(self):
                return 0
        empty = EmptyList()
        def __init__(self, first, rest=empty):
            self.first = first
            self.rest = rest
        def __repr__(self):
            args = repr(self.first)
            if self.rest is not Rlist.empty:
                args += ', {0}'.format(repr(self.rest))
            return 'Rlist({0})'.format(args)
        def __len__(self):
            return 1 + len(self.rest)
        def __getitem__(self, i):
            if i == 0:
                return self.first
            return self.rest[i-1]
</pre>
<p>The definitions of <tt class="docutils literal">__len__</tt> and <tt class="docutils literal">__getitem__</tt> are in fact recursive,
although not explicitly so.  The built-in Python function <tt class="docutils literal">len</tt> looks for a
method called <tt class="docutils literal">__len__</tt> when applied to a user-defined object argument.
Likewise, the subscript operator looks for a method called <tt class="docutils literal">__getitem__</tt>.
Thus, these definitions will end up calling themselves. Recursive calls on the
rest of the list are a ubiquitous pattern in recursive list processing.  This
class definition of a recursive list interacts properly with Python's built-in
sequence and printing operations.</p>
<pre class="doctest-block">
&gt;&gt;&gt; s = Rlist(1, Rlist(2, Rlist(3)))
&gt;&gt;&gt; s.rest
Rlist(2, Rlist(3))
&gt;&gt;&gt; len(s)
3
&gt;&gt;&gt; s[1]
2
</pre>
<p>Operations that create new lists are particularly straightforward to express
using recursion. For example, we can define a function <tt class="docutils literal">extend_rlist</tt>, which
takes two recursive lists as arguments and combines the elements of both into
a new list.</p>
<pre class="doctest-block">
&gt;&gt;&gt; def extend_rlist(s1, s2):
        if s1 is Rlist.empty:
            return s2
        return Rlist(s1.first, extend_rlist(s1.rest, s2))
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; extend_rlist(s.rest, s)
Rlist(2, Rlist(3, Rlist(1, Rlist(2, Rlist(3)))))
</pre>
<p>Likewise, mapping a function over a recursive list exhibits a similar pattern.</p>
<pre class="doctest-block">
&gt;&gt;&gt; def map_rlist(s, fn):
        if s is Rlist.empty:
            return s
        return Rlist(fn(s.first), map_rlist(s.rest, fn))
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; map_rlist(s, square)
Rlist(1, Rlist(4, Rlist(9)))
</pre>
<p>Filtering includes an additional conditional statement, but otherwise has a
similar recursive structure.</p>
<pre class="doctest-block">
&gt;&gt;&gt; def filter_rlist(s, fn):
        if s is Rlist.empty:
            return s
        rest = filter_rlist(s.rest, fn)
        if fn(s.first):
            return Rlist(s.first, rest)
        return rest
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; filter_rlist(s, lambda x: x % 2 == 1)
Rlist(1, Rlist(3))
</pre>
<p>Recursive implementations of list operations do not, in general, require local
assignment or <tt class="docutils literal">while</tt> statements.  Instead, recursive lists are taken apart
and constructed incrementally as a consequence of function application. As a
result, they have linear orders of growth in both the number of steps and space
required.</p>
</div>
<div class="section" id="hierarchical-structures">
<h2><a class="toc-backref" href="#id15">3.3.2&nbsp;&nbsp;&nbsp;Hierarchical Structures</a></h2>
<p>Hierarchical structures result from the closure property of data, which asserts
for example that tuples can contain other tuples.  For instance, consider this
nested representation of the numbers 1 through 4.</p>
<pre class="doctest-block">
&gt;&gt;&gt; ((1, 2), 3, 4)
((1, 2), 3, 4)
</pre>
<p>This tuple is a length-three sequence, of which the first element is itself a
tuple. A box-and-pointer diagram of this nested structure shows that it can also
be thought of as a tree with four leaves, each of which is a number.</p>
<div class="figure">
<img alt="img/tree.png" src="img/tree.png" />
</div>
<p>In a tree, each subtree is itself a tree.  As a base condition, any bare element
that is not a tuple is itself a simple tree, one with no branches. That is, the
numbers are all trees, as is the pair <tt class="docutils literal">(1, 2)</tt> and the structure as a whole.</p>
<p>Recursion is a natural tool for dealing with tree structures, since we can often
reduce operations on trees to operations on their branches, which reduce in turn
to operations on the branches of the branches, and so on, until we reach the
leaves of the tree. As an example, we can implement a <tt class="docutils literal">count_leaves</tt>
function, which returns the total number of leaves of a tree.</p>
<pre class="doctest-block">
&gt;&gt;&gt; def count_leaves(tree):
        if type(tree) != tuple:
            return 1
        return sum(map(count_leaves, tree))
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; t = ((1, 2), 3, 4)
&gt;&gt;&gt; count_leaves(t)
4
&gt;&gt;&gt; big_tree = ((t, t), 5)
&gt;&gt;&gt; big_tree
((((1, 2), 3, 4), ((1, 2), 3, 4)), 5)
&gt;&gt;&gt; count_leaves(big_tree)
9
</pre>
<p>Just as <tt class="docutils literal">map</tt> is a powerful tool for dealing with sequences, mapping and
recursion together provide a powerful general form of computation for
manipulating trees.  For instance, we can square all leaves of a tree using a
higher-order recursive function <tt class="docutils literal">map_tree</tt> that is structured quite similarly
to <tt class="docutils literal">count_leaves</tt>.</p>
<pre class="doctest-block">
&gt;&gt;&gt; def map_tree(tree, fn):
        if type(tree) != tuple:
            return fn(tree)
        return tuple(map_tree(branch, fn) for branch in tree)
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; map_tree(big_tree, square)
((((1, 4), 9, 16), ((1, 4), 9, 16)), 25)
</pre>
<p><strong>Internal values.</strong> The trees described above have values only at the
leaves.  Another common representation of tree-structured data has values for
the internal nodes of the tree as well. We can represent such trees using a
class.</p>
<pre class="doctest-block">
&gt;&gt;&gt; class Tree(object):
        def __init__(self, entry, left=None, right=None):
            self.entry = entry
            self.left = left
            self.right = right
        def __repr__(self):
            args = repr(self.entry)
            if self.left or self.right:
                args += ', {0}, {1}'.format(repr(self.left), repr(self.right))
            return 'Tree({0})'.format(args)
</pre>
<p>The <tt class="docutils literal">Tree</tt> class can represent, for instance, the values computed in an
expression tree for the recursive implementation of <tt class="docutils literal">fib</tt>, the function for
computing Fibonacci numbers. The function <tt class="docutils literal">fib_tree(n)</tt> below returns a
<tt class="docutils literal">Tree</tt> that has the nth Fibonacci number as its <tt class="docutils literal">entry</tt> and a trace of all
previously computed Fibonacci numbers within its branches.</p>
<pre class="doctest-block">
&gt;&gt;&gt; def fib_tree(n):
        &quot;&quot;&quot;Return a Tree that represents a recursive Fibonacci calculation.&quot;&quot;&quot;
        if n == 1:
            return Tree(0)
        if n == 2:
            return Tree(1)
        left = fib_tree(n-2)
        right = fib_tree(n-1)
        return Tree(left.entry + right.entry, left, right)
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; fib_tree(5)
Tree(3, Tree(1, Tree(0), Tree(1)), Tree(2, Tree(1), Tree(1, Tree(0), Tree(1))))
</pre>
<p>This example shows that expression trees can be represented programmatically
using tree-structured data. This connection between nested expressions and
tree-structured data type plays a central role in our discussion of designing
interpreters later in this chapter.</p>
</div>
<div class="section" id="sets">
<h2><a class="toc-backref" href="#id16">3.3.3&nbsp;&nbsp;&nbsp;Sets</a></h2>
<p>In addition to the list, tuple, and dictionary, Python has a fourth built-in
container type called a <tt class="docutils literal">set</tt>. Set literals follow the mathematical notation
of elements enclosed in braces.  Duplicate elements are removed upon
construction.  Sets are unordered collections, and so the printed ordering may
differ from the element ordering in the set literal.</p>
<pre class="doctest-block">
&gt;&gt;&gt; s = {3, 2, 1, 4, 4}
&gt;&gt;&gt; s
{1, 2, 3, 4}
</pre>
<p>Python sets support a variety of operations, including membership tests, length
computation, and the standard set operations of union and intersection</p>
<pre class="doctest-block">
&gt;&gt;&gt; 3 in s
True
&gt;&gt;&gt; len(s)
4
&gt;&gt;&gt; s.union({1, 5})
{1, 2, 3, 4, 5}
&gt;&gt;&gt; s.intersection({6, 5, 4, 3})
{3, 4}
</pre>
<p>In addition to <tt class="docutils literal">union</tt> and <tt class="docutils literal">intersection</tt>, Python sets support several
other methods. The predicates <tt class="docutils literal">isdisjoint</tt>, <tt class="docutils literal">issubset</tt>, and <tt class="docutils literal">issuperset</tt>
provide set comparison.  Sets are mutable, and can be changed one element at a
time using <tt class="docutils literal">add</tt>, <tt class="docutils literal">remove</tt>, <tt class="docutils literal">discard</tt>, and <tt class="docutils literal">pop</tt>.  Additional methods
provide multi-element mutations, such as <tt class="docutils literal">clear</tt> and <tt class="docutils literal">update</tt>. The Python
<a class="reference external" href="http://docs.python.org/py3k/library/stdtypes.html#set">documentation for sets</a> should be
sufficiently intelligible at this point of the course to fill in the details.</p>
<p><strong>Implementing sets.</strong> Abstractly, a set is a collection of distinct objects
that supports membership testing, union, intersection, and adjunction.
Adjoining an element and a set returns a new set that contains all of the
original set's elements along with the new element, if it is distinct. Union
and intersection return the set of elements that appear in either or both sets,
respectively. As with any data abstraction, we are free to implement any
functions over any representation of sets that provides this collection of
behaviors.</p>
<p>In the remainder of this section, we consider three different methods of
implementing sets that vary in their representation. We will characterize the
efficiency of these different representations by analyzing the order of growth
of set operations.  We will use our <tt class="docutils literal">Rlist</tt> and <tt class="docutils literal">Tree</tt> classes from earlier
in this section, which allow for simple and elegant recursive solutions for
elementary set operations.</p>
<p><strong>Sets as unordered sequences.</strong> One way to represent a set is as a sequence in
which no element appears more than once.  The empty set is represented by the
empty sequence. Membership testing walks recursively through the list.</p>
<pre class="doctest-block">
&gt;&gt;&gt; def empty(s):
        return s is Rlist.empty
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; def set_contains(s, v):
        &quot;&quot;&quot;Return True if and only if set s contains v.&quot;&quot;&quot;
        if empty(s):
            return False
        elif s.first == v:
            return True
        return set_contains(s.rest, v)
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; s = Rlist(1, Rlist(2, Rlist(3)))
&gt;&gt;&gt; set_contains(s, 2)
True
&gt;&gt;&gt; set_contains(s, 5)
False
</pre>
<p>This implementation of <tt class="docutils literal">set_contains</tt> requires \(\Theta(n)\) time to test
membership of an element, where \(n\) is the size of the set <tt class="docutils literal">s</tt>. Using
this linear-time function for membership, we can adjoin an element to a set,
also in linear time.</p>
<pre class="doctest-block">
&gt;&gt;&gt; def adjoin_set(s, v):
        &quot;&quot;&quot;Return a set containing all elements of s and element v.&quot;&quot;&quot;
        if set_contains(s, v):
            return s
        return Rlist(v, s)
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; t = adjoin_set(s, 4)
&gt;&gt;&gt; t
Rlist(4, Rlist(1, Rlist(2, Rlist(3))))
</pre>
<p>In designing a representation, one of the issues with which we should be
concerned is efficiency.  Intersecting two sets <tt class="docutils literal">set1</tt> and <tt class="docutils literal">set2</tt> also
requires membership testing, but this time each element of <tt class="docutils literal">set1</tt> must be
tested for membership in <tt class="docutils literal">set2</tt>, leading to a quadratic order of growth in
the number of steps, \(\Theta(n^2)\), for two sets of size \(n\).</p>
<pre class="doctest-block">
&gt;&gt;&gt; def intersect_set(set1, set2):
        &quot;&quot;&quot;Return a set containing all elements common to set1 and set2.&quot;&quot;&quot;
        return filter_rlist(set1, lambda v: set_contains(set2, v))
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; intersect_set(t, map_rlist(s, square))
Rlist(4, Rlist(1))
</pre>
<p>When computing the union of two sets, we must be careful not to include any
element twice.  The <tt class="docutils literal">union_set</tt> function also requires a linear number of
membership tests, creating a process that also includes \(\Theta(n^2)\)
steps.</p>
<pre class="doctest-block">
&gt;&gt;&gt; def union_set(set1, set2):
        &quot;&quot;&quot;Return a set containing all elements either in set1 or set2.&quot;&quot;&quot;
        set1_not_set2 = filter_rlist(set1, lambda v: not set_contains(set2, v))
        return extend_rlist(set1_not_set2, set2)
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; union_set(t, s)
Rlist(4, Rlist(1, Rlist(2, Rlist(3))))
</pre>
<p><strong>Sets as ordered tuples.</strong> One way to speed up our set operations is to change
the representation so that the set elements are listed in increasing order. To
do this, we need some way to compare two objects so that we can say which is
bigger. In Python, many different types of objects can be compared using <tt class="docutils literal">&lt;</tt>
and <tt class="docutils literal">&gt;</tt> operators, but we will concentrate on numbers in this example. We will
represent a set of numbers by listing its elements in increasing order.</p>
<p>One advantage of ordering shows up in <tt class="docutils literal">set_contains</tt>: In checking for the
presence of an object, we no longer have to scan the entire set. If we reach a
set element that is larger than the item we are looking for, then we know that
the item is not in the set:</p>
<pre class="doctest-block">
&gt;&gt;&gt; def set_contains(s, v):
        if empty(s) or s.first &gt; v:
            return False
        elif s.first == v:
            return True
        return set_contains(s.rest, v)
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; set_contains(s, 0)
False
</pre>
<p>How many steps does this save? In the worst case, the item we are looking for
may be the largest one in the set, so the number of steps is the same as for
the unordered representation. On the other hand, if we search for items of many
different sizes we can expect that sometimes we will be able to stop searching
at a point near the beginning of the list and that other times we will still
need to examine most of the list. On average we should expect to have to
examine about half of the items in the set. Thus, the average number of steps
required will be about \(\frac{n}{2}\). This is still \(\Theta(n)\)
growth, but it does save us, on average, a factor of <tt class="docutils literal">2</tt> in the number of
steps over the previous implementation.</p>
<p>We can obtain a more impressive speedup by re-implementing <tt class="docutils literal">intersect_set</tt>.
In the unordered representation, this operation required \(\Theta(n^2)\)
steps because we performed a complete scan of <tt class="docutils literal">set2</tt> for each element of
<tt class="docutils literal">set1</tt>. But with the ordered representation, we can use a more clever method.
We iterate through both sets simultaneously, tracking an element <tt class="docutils literal">e1</tt> in
<tt class="docutils literal">set1</tt> and <tt class="docutils literal">e2</tt> in <tt class="docutils literal">set2</tt>.  When <tt class="docutils literal">e1</tt> and <tt class="docutils literal">e2</tt> are equal, we include
that element in the intersection.</p>
<p>Suppose, however, that <tt class="docutils literal">e1</tt> is less than <tt class="docutils literal">e2</tt>. Since <tt class="docutils literal">e2</tt> is smaller than
the remaining elements of <tt class="docutils literal">set2</tt>, we can immediately conclude that <tt class="docutils literal">e1</tt>
cannot appear anywhere in the remainder of <tt class="docutils literal">set2</tt> and hence is not in the
intersection. Thus, we no longer need to consider <tt class="docutils literal">e1</tt>; we discard it and
proceed to the next element of <tt class="docutils literal">set1</tt>.  Similar logic advances through the
elements of <tt class="docutils literal">set2</tt> when <tt class="docutils literal">e2 &lt; e1</tt>. Here is the function:</p>
<pre class="doctest-block">
&gt;&gt;&gt; def intersect_set(set1, set2):
        if empty(set1) or empty(set2):
            return Rlist.empty
        e1, e2 = set1.first, set2.first
        if e1 == e2:
            return Rlist(e1, intersect_set(set1.rest, set2.rest))
        elif e1 &lt; e2:
            return intersect_set(set1.rest, set2)
        elif e2 &lt; e1:
            return intersect_set(set1, set2.rest)
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; intersect_set(s, s.rest)
Rlist(2, Rlist(3))
</pre>
<p>To estimate the number of steps required by this process, observe that in each
step we shrink the size of at least one of the sets. Thus, the number of steps
required is at most the sum of the sizes of <tt class="docutils literal">set1</tt> and <tt class="docutils literal">set2</tt>, rather than
the product of the sizes, as with the unordered representation. This is
\(\Theta(n)\) growth rather than \(\Theta(n^2)\) -- a considerable
speedup, even for sets of moderate size. For example, the intersection of two
sets of size <tt class="docutils literal">100</tt> will take around <tt class="docutils literal">200</tt> steps, rather than <tt class="docutils literal">10,000</tt> for
the unordered representation.</p>
<p>Adjunction and union for sets represented as ordered sequences can also be
computed in linear time.  These implementations are left as an exercise.</p>
<p><strong>Sets as binary trees.</strong> We can do better than the ordered-list representation
by arranging the set elements in the form of a tree. We use the <tt class="docutils literal">Tree</tt> class
introduced previously. The <tt class="docutils literal">entry</tt> of the root of the tree holds one element
of the set. The entries within the <tt class="docutils literal">left</tt> branch include all elements smaller
than the one at the root. Entries in the <tt class="docutils literal">right</tt> branch include all elements
greater than the one at the root. The figure below shows some trees that
represent the set <tt class="docutils literal">{1, 3, 5, 7, 9, 11}</tt>. The same set may be represented by a
tree in a number of different ways. The only thing we require for a valid
representation is that all elements in the <tt class="docutils literal">left</tt> subtree be smaller than the
tree <tt class="docutils literal">entry</tt> and that all elements in the <tt class="docutils literal">right</tt> subtree be larger.</p>
<div class="figure">
<img alt="img/set_trees.png" src="img/set_trees.png" />
</div>
<p>The advantage of the tree representation is this: Suppose we want to check
whether a value <tt class="docutils literal">v</tt> is contained in a set. We begin by comparing <tt class="docutils literal">v</tt> with
<tt class="docutils literal">entry</tt>. If <tt class="docutils literal">v</tt> is less than this, we know that we need only search the
<tt class="docutils literal">left</tt> subtree; if <tt class="docutils literal">v</tt> is greater, we need only search the <tt class="docutils literal">right</tt>
subtree. Now, if the tree is &quot;balanced,&quot; each of these subtrees will be about
half the size of the original. Thus, in one step we have reduced the problem of
searching a tree of size \(n\) to searching a tree of size
\(\frac{n}{2}\). Since the size of the tree is halved at each step, we
should expect that the number of steps needed to search a tree grows as
\(\Theta(\log n)\). For large sets, this will be a significant speedup over the
previous representations.  This <tt class="docutils literal">set_contains</tt> function exploits the ordering
structure of the tree-structured set.</p>
<pre class="doctest-block">
&gt;&gt;&gt; def set_contains(s, v):
        if s is None:
            return False
        elif s.entry == v:
            return True
        elif s.entry &lt; v:
            return set_contains(s.right, v)
        elif s.entry &gt; v:
            return set_contains(s.left, v)
</pre>
<p>Adjoining an item to a set is implemented similarly and also requires
\(\Theta(\log n)\) steps. To adjoin a value <tt class="docutils literal">v</tt>, we compare <tt class="docutils literal">v</tt> with
<tt class="docutils literal">entry</tt> to determine whether <tt class="docutils literal">v</tt> should be added to the <tt class="docutils literal">right</tt> or to the
<tt class="docutils literal">left</tt> branch, and having adjoined <tt class="docutils literal">v</tt> to the appropriate branch we piece
this newly constructed branch together with the original <tt class="docutils literal">entry</tt> and the
other branch.  If <tt class="docutils literal">v</tt> is equal to the <tt class="docutils literal">entry</tt>, we just return the node. If
we are asked to adjoin <tt class="docutils literal">v</tt> to an empty tree, we generate a <tt class="docutils literal">Tree</tt> that has
<tt class="docutils literal">v</tt> as the <tt class="docutils literal">entry</tt> and empty <tt class="docutils literal">right</tt> and <tt class="docutils literal">left</tt> branches. Here is the
function:</p>
<pre class="doctest-block">
&gt;&gt;&gt; def adjoin_set(s, v):
        if s is None:
            return Tree(v)
        if s.entry == v:
            return s
        if s.entry &lt; v:
            return Tree(s.entry, s.left, adjoin_set(s.right, v))
        if s.entry &gt; v:
            return Tree(s.entry, adjoin_set(s.left, v), s.right)
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; adjoin_set(adjoin_set(adjoin_set(None, 2), 3), 1)
Tree(2, Tree(1), Tree(3))
</pre>
<p>Our claim that searching the tree can be performed in a logarithmic number
of steps rests on the assumption that the tree is &quot;balanced,&quot; i.e., that the
left and the right subtree of every tree have approximately the same number of
elements, so that each subtree contains about half the elements of its parent.
But how can we be certain that the trees we construct will be balanced? Even if
we start with a balanced tree, adding elements with <tt class="docutils literal">adjoin_set</tt> may produce
an unbalanced result. Since the position of a newly adjoined element depends on
how the element compares with the items already in the set, we can expect that
if we add elements &quot;randomly&quot; the tree will tend to be balanced on the average.</p>
<p>But this is not a guarantee. For example, if we start with an empty set and
adjoin the numbers 1 through 7 in sequence we end up with a highly unbalanced
tree in which all the left subtrees are empty, so it has no advantage over a
simple ordered list. One way to solve this problem is to define an operation
that transforms an arbitrary tree into a balanced tree with the same elements.
We can perform this transformation after every few <tt class="docutils literal">adjoin_set</tt> operations to
keep our set in balance.</p>
<p>Intersection and union operations can be performed on tree-structured sets
in linear time by converting them to ordered lists and back. The details are
left as an exercise.</p>
<p><strong>Python set implementation.</strong> The <tt class="docutils literal">set</tt> type that is built into Python does
not use any of these representations internally.  Instead, Python uses a
representation that gives constant-time membership tests and adjoin operations
based on a technique called <em>hashing</em>, which is a topic for another course.
Built-in Python sets cannot contain mutable data types, such as lists,
dictionaries, or other sets.  To allow for nested sets, Python also includes a
built-in immutable <tt class="docutils literal">frozenset</tt> class that shares methods with the <tt class="docutils literal">set</tt>
class but excludes mutation methods and operators.</p>
</div>
</div>
<div class="section" id="exceptions">
<h1><a class="toc-backref" href="#id17">3.4&nbsp;&nbsp;&nbsp;Exceptions</a></h1>
<p>Programmers must be always mindful of possible errors that may arise in their
programs. Examples abound: a function may not receive arguments that it is
designed to accept, a necessary resource may be missing, or a connection across
a network may be lost. When designing a program, one must anticipate the
exceptional circumstances that may arise and take appropriate measures to
handle them.</p>
<p>There is no single correct approach to handling errors in a program.  Programs
designed to provide some persistent service like a web server should be robust
to errors, logging them for later consideration but continuing to service new
requests as long as possible. On the other hand, the Python interpreter handles
errors by terminating immediately and printing an error message, so that
programmers can address issues as soon as they arise. In any case, programmers
must make conscious choices about how their programs should react to
exceptional conditions.</p>
<p><em>Exceptions</em>, the topic of this section, provides a general mechanism for
adding error-handling logic to programs. <em>Raising an exception</em> is a technique
for interrupting the normal flow of execution in a program, signaling that
some exceptional circumstance has arisen, and returning directly to an
enclosing part of the program that was designated to react to that
circumstance.  The Python interpreter raises an exception each time it detects
an error in an expression or statement.  Users can also raise exceptions with
<tt class="docutils literal">raise</tt> and <tt class="docutils literal">assert</tt> statements.</p>
<p><strong>Raising exceptions.</strong> An exception is a object instance with a class that
inherits, either directly or indirectly, from the <tt class="docutils literal">BaseException</tt> class. The
<tt class="docutils literal">assert</tt> statement introduced in Chapter 1 raises an exception with the class
<tt class="docutils literal">AssertionError</tt>.  In general, any exception instance can be raised with the <tt class="docutils literal">raise</tt>
statement. The general form of raise statements are described in the <a class="reference external" href="http://docs.python.org/py3k/reference/simple_stmts.html#raise">Python
docs</a>. The
most common use of <tt class="docutils literal">raise</tt> constructs an exception instance and raises it.</p>
<pre class="doctest-block">
&gt;&gt;&gt; raise Exception('An error occurred')
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
Exception: an error occurred
</pre>
<p>When an exception is raised, no further statements in the current block of code
are executed. Unless the exception is <em>handled</em> (described below), the
interpreter will return directly to the interactive read-eval-print loop, or
terminate entirely if Python was started with a file argument. In addition, the
interpreter will print a <em>stack backtrace</em>, which is a structured block of text
that describes the nested set of active function calls in the branch of
execution in which the exception was raised. In the example above, the file
name <tt class="docutils literal">&lt;stdin&gt;</tt> indicates that the exception was raised by the user in an
interactive session, rather than from code in a file.</p>
<p><strong>Handling exceptions.</strong> An exception can be handled by an enclosing <tt class="docutils literal">try</tt>
statement. A <tt class="docutils literal">try</tt> statement consists of multiple clauses; the first begins
with <tt class="docutils literal">try</tt> and the rest begin with <tt class="docutils literal">except</tt>:</p>
<pre class="literal-block">
try:
    &lt;try suite&gt;
except &lt;exception class&gt; as &lt;name&gt;:
    &lt;except suite&gt;
...
</pre>
<p>The <tt class="docutils literal">&lt;try suite&gt;</tt> is always executed immediately when the <tt class="docutils literal">try</tt> statement
is executed.  Suites of the <tt class="docutils literal">except</tt> clauses are only executed when an
exception is raised during the course of executing the <tt class="docutils literal">&lt;try suite&gt;</tt>. Each
<tt class="docutils literal">except</tt> clause specifies the particular class of exception to handle. For
instance, if the <tt class="docutils literal">&lt;exception class&gt;</tt> is <tt class="docutils literal">AssertionError</tt>, then any instance
of a class inheriting from <tt class="docutils literal">AssertionError</tt> that is raised during the course
of executing the <tt class="docutils literal">&lt;try suite&gt;</tt> will be handled by the following <tt class="docutils literal">&lt;except
suite&gt;</tt>. Within the <tt class="docutils literal">&lt;except suite&gt;</tt>, the identifier <tt class="docutils literal">&lt;name&gt;</tt> is bound to
the exception object that was raised, but this binding does not persist beyond
the <tt class="docutils literal">&lt;except suite&gt;</tt>.</p>
<p>For example, we can handle a <tt class="docutils literal">ZeroDivisionError</tt> exception using a <tt class="docutils literal">try</tt>
statement that binds the name <tt class="docutils literal">x</tt> to <tt class="docutils literal">0</tt> when the exception is raised.</p>
<pre class="doctest-block">
&gt;&gt;&gt; try:
        x = 1/0
    except ZeroDivisionError as e:
        print('handling a', type(e))
        x = 0
handling a &lt;class 'ZeroDivisionError'&gt;
&gt;&gt;&gt; x
0
</pre>
<p>A <tt class="docutils literal">try</tt> statement will handle exceptions that occur within the body of a
function that is applied (either directly or indirectly) within the <tt class="docutils literal">&lt;try
suite&gt;</tt>.  When an exception is raised, control jumps directly to the body of
the <tt class="docutils literal">&lt;except suite&gt;</tt> of the most recent <tt class="docutils literal">try</tt> statement that handles that
type of exception.</p>
<pre class="doctest-block">
&gt;&gt;&gt; def invert(x):
        result = 1/x  # Raises a ZeroDivisionError if x is 0
        print('Never printed if x is 0')
        return result
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; def invert_safe(x):
        try:
            return invert(x)
        except ZeroDivisionError as e:
            return str(e)
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; invert_safe(2)
Never printed if x is 0
0.5
&gt;&gt;&gt; invert_safe(0)
'division by zero'
</pre>
<p>This example illustrates that the <tt class="docutils literal">print</tt> expression in <tt class="docutils literal">invert</tt> is never
evaluated, and instead control is transferred to the suite of the <tt class="docutils literal">except</tt>
clause in <tt class="docutils literal">handler</tt>. Coercing the <tt class="docutils literal">ZeroDivisionError</tt> <tt class="docutils literal">e</tt> to a
string gives the human-interpretable string returned by <tt class="docutils literal">handler</tt>:
<tt class="docutils literal">'division by zero'</tt>.</p>
<div class="section" id="exception-objects">
<h2><a class="toc-backref" href="#id18">3.4.1&nbsp;&nbsp;&nbsp;Exception Objects</a></h2>
<p>Exception objects themselves carry attributes, such as the error message stated
in an <tt class="docutils literal">assert</tt> statement and information about where in the course of
execution the exception was raised. User-defined exception classes can carry
additional attributes.</p>
<p>In Chapter 1, we implemented Newton's method to find the zeroes of arbitrary
functions. The following example defines an exception class that returns the
best guess discovered in the course of iterative improvement whenever a
<tt class="docutils literal">ValueError</tt> occurs. A math domain error (a type of <tt class="docutils literal">ValueError</tt>) is raised
when <tt class="docutils literal">sqrt</tt> is applied to a negative number. This exception is handled by
raising an <tt class="docutils literal">IterImproveError</tt> that stores the most recent guess from Newton's
method as an attribute.</p>
<p>First, we define a new class that inherits from <tt class="docutils literal">Exception</tt>.</p>
<pre class="doctest-block">
&gt;&gt;&gt; class IterImproveError(Exception):
        def __init__(self, last_guess):
            self.last_guess = last_guess
</pre>
<p>Next, we define a version of <tt class="docutils literal">IterImprove</tt>, our generic iterative improvement
algorithm.  This version handles any <tt class="docutils literal">ValueError</tt> by raising an
<tt class="docutils literal">IterImproveError</tt> that stores the most recent guess. As before,
<tt class="docutils literal">iter_improve</tt> takes as arguments two functions, each of which takes a
single numerical argument. The <tt class="docutils literal">update</tt> function returns new guesses, while
the <tt class="docutils literal">done</tt> function returns a boolean indicating that improvement has
converged to a correct value.</p>
<pre class="doctest-block">
&gt;&gt;&gt; def iter_improve(update, done, guess=1, max_updates=1000):
        k = 0
        try:
            while not done(guess) and k &lt; max_updates:
                guess = update(guess)
                k = k + 1
            return guess
        except ValueError:
            raise IterImproveError(guess)
</pre>
<p>Finally, we define <tt class="docutils literal">find_root</tt>, which returns the result of <tt class="docutils literal">iter_improve</tt>
applied to a Newton update function returned by <tt class="docutils literal">newton_update</tt>, which is
defined in Chapter 1 and requires no changes for this example. This version of
<tt class="docutils literal">find_root</tt> handles an <tt class="docutils literal">IterImproveError</tt> by returning its last guess.</p>
<pre class="doctest-block">
&gt;&gt;&gt; def find_root(f, guess=1):
        def done(x):
            return f(x) == 0
        try:
            return iter_improve(newton_update(f), done, guess)
        except IterImproveError as e:
            return e.last_guess
</pre>
<p>Consider applying <tt class="docutils literal">find_root</tt> to find the zero of the function \(2x^2 +
\sqrt{x}\). This function has a zero at <tt class="docutils literal">0</tt>, but evaluating it on any negative
number will raise a <tt class="docutils literal">ValueError</tt>. Our Chapter 1 implementation of Newton's
Method would raise that error and fail to return any guess of the zero.  Our
revised implementation returns the last guess found before the error.</p>
<pre class="doctest-block">
&gt;&gt;&gt; from math import sqrt
&gt;&gt;&gt; find_root(lambda x: 2*x*x + sqrt(x))
-0.030211203830201594
</pre>
<p>While this approximation is still far from the correct answer of <tt class="docutils literal">0</tt>, some
applications would prefer this coarse approximation to a <tt class="docutils literal">ValueError</tt>.</p>
<p>Exceptions are another technique that help us as programs to separate the
concerns of our program into modular parts.  In this example, Python's
exception mechanism allowed us to separate the logic for iterative improvement,
which appears unchanged in the suite of the <tt class="docutils literal">try</tt> clause, from the logic for
handling errors, which appears in <tt class="docutils literal">except</tt> clauses. We will also find that
exceptions are a very useful feature when implementing interpreters in Python.</p>
</div>
</div>
<div class="section" id="interpreters-for-languages-with-combination">
<h1><a class="toc-backref" href="#id19">3.5&nbsp;&nbsp;&nbsp;Interpreters for Languages with Combination</a></h1>
<p>The software running on any modern computer is written in a variety of
programming languages. There are physical languages, such as the machine
languages for particular computers. These languages are concerned with the
representation of data and control in terms of individual bits of storage and
primitive machine instructions. The machine-language programmer is concerned
with using the given hardware to erect systems and utilities for the efficient
implementation of resource-limited computations. High-level languages, erected
on a machine-language substrate, hide concerns about the representation of data
as collections of bits and the representation of programs as sequences of
primitive instructions. These languages have means of combination and
abstraction, such as procedure definition, that are appropriate to the
larger-scale organization of software systems.</p>
<p><em>Metalinguistic abstraction</em> -- establishing new languages -- plays an
important role in all branches of engineering design. It is particularly
important to computer programming, because in programming not only can we
formulate new languages but we can also implement these languages by
constructing interpreters. An interpreter for a programming language is a
function that, when applied to an expression of the language, performs the
actions required to evaluate that expression.</p>
<p>We now embark on a tour of the technology by which languages are established in
terms of other languages. We will first define an interpreter for a limited
language called Calculator that shares the syntax of Python call expressions.
We will then develop a sketch interpreters for the Scheme and Logo languages,
which is are dialects of Lisp, the second oldest language still in
widespread use today.
The interpreter we create will be complete in the sense that it will allow us
to write fully general programs in Logo. To do so, it will implement the
environment model of evaluation that we have developed over the course of this
text.</p>
<div class="section" id="calculator">
<h2><a class="toc-backref" href="#id20">3.5.1&nbsp;&nbsp;&nbsp;Calculator</a></h2>
<p>Our first new language is Calculator, an expression language for the arithmetic
operations of addition, subtraction, multiplication, and division. Calculator
shares Python's call expression syntax, but its operators are more flexible in
the number of arguments they accept. For instance, the Calculator operators
<tt class="docutils literal">add</tt> and <tt class="docutils literal">mul</tt> take an arbitrary number of arguments:</p>
<pre class="literal-block">
calc&gt; add(1, 2, 3, 4)
10
calc&gt; mul()
1
</pre>
<p>The <tt class="docutils literal">sub</tt> operator has two behaviors.  With one argument, it negates the
argument.  With at least two arguments, it subtracts all but the first from the
first.  The <tt class="docutils literal">div</tt> operator has the semantics of Python's <tt class="docutils literal">operator.truediv</tt>
function and takes exactly two arguments:</p>
<pre class="literal-block">
calc&gt; sub(10, 1, 2, 3)
4
calc&gt; sub(3)
-3
calc&gt; div(15, 12)
1.25
</pre>
<p>As in Python, call expression nesting provides a means of combination in the
Calculator language. To condense notation, the names of operators can also be
replaced by their standard symbols:</p>
<pre class="literal-block">
calc&gt; sub(100, mul(7, add(8, div(-12, -3))))
16.0
calc&gt; -(100, *(7, +(8, /(-12, -3))))
16.0
</pre>
<p>We will implement an interpreter for Calculator in Python.  That is, we will
write a Python program that takes a string as input and either returns the
result of evaluating that string if it is a well-formed Calculator expression
or raises an appropriate exception if it is not.  The core of the interpreter
for the Calculator language is a recursive function called <tt class="docutils literal">calc_eval</tt> that
evaluates a tree-structured expression object.</p>
<p><strong>Expression trees.</strong> Until this point in the course, expression trees have
been conceptual entities to which we have referred in describing the process of
evaluation; we have never before explicitly represented expression trees as
data in our programs. In order to write an interpreter, we must operate on
expressions as data. In the course of this chapter, many of the concepts
introduced in previous chapters will finally by realized in code.</p>
<p>A primitive expression is just a number in Calculator, either an <tt class="docutils literal">int</tt> or
<tt class="docutils literal">float</tt> type. All combined expressions are call expressions.  A call
expression is represented as a class <tt class="docutils literal">Exp</tt> that has two attribute instances.
The <tt class="docutils literal">operator</tt> in Calculator is always a string: an arithmetic operator name
or symbol.  The <tt class="docutils literal">operands</tt> are either primitive expressions or themselves
instances of <tt class="docutils literal">Exp</tt>.</p>
<pre class="doctest-block">
&gt;&gt;&gt; class Exp(object):
        &quot;&quot;&quot;A call expression in Calculator.&quot;&quot;&quot;
        def __init__(self, operator, operands):
            self.operator = operator
            self.operands = operands
        def __repr__(self):
            return 'Exp({0}, {1})'.format(repr(self.operator), repr(self.operands))
        def __str__(self):
            operand_strs = ', '.join(map(str, self.operands))
            return '{0}({1})'.format(self.operator, operand_strs)
</pre>
<p>An <tt class="docutils literal">Exp</tt> instance defines two string methods. The <tt class="docutils literal">__repr__</tt> method returns
Python expression, while the <tt class="docutils literal">__str__</tt> method returns a Calculator expression.</p>
<pre class="doctest-block">
&gt;&gt;&gt; Exp('add', [1, 2])
Exp('add', [1, 2])
&gt;&gt;&gt; str(Exp('add', [1, 2]))
'add(1, 2)'
&gt;&gt;&gt; Exp('add', [1, Exp('mul', [2, 3, 4])])
Exp('add', [1, Exp('mul', [2, 3, 4])])
&gt;&gt;&gt; str(Exp('add', [1, Exp('mul', [2, 3, 4])]))
'add(1, mul(2, 3, 4))'
</pre>
<p>This final example demonstrates how the <tt class="docutils literal">Exp</tt> class represents the
hierarchical structure in expression trees by including instances of <tt class="docutils literal">Exp</tt> as
elements of <tt class="docutils literal">operands</tt>.</p>
<p><strong>Evaluation.</strong> The <tt class="docutils literal">calc_eval</tt> function itself takes an expression as an
argument and returns its value. It classifies the expression by its form and
directs its evaluation. For Calculator, the only two syntactic forms of
expressions are numbers and call expressions, which are <tt class="docutils literal">Exp</tt> instances.
Numbers are <em>self-evaluating</em>; they can be returned directly from
<tt class="docutils literal">calc_eval</tt>. Call expressions require function application.</p>
<pre class="doctest-block">
&gt;&gt;&gt; def calc_eval(exp):
        &quot;&quot;&quot;Evaluate a Calculator expression.&quot;&quot;&quot;
        if type(exp) in (int, float):
            return exp
        elif type(exp) == Exp:
            arguments = list(map(calc_eval, exp.operands))
            return calc_apply(exp.operator, arguments)
</pre>
<p>Call expressions are evaluated by first recursively mapping the <tt class="docutils literal">calc_eval</tt>
function to the list of operands to compute a list of <tt class="docutils literal">arguments</tt>.  Then, the
operator is applied to those arguments in a second function, <tt class="docutils literal">calc_apply</tt>.</p>
<p>The Calculator language is simple enough that we can easily express the logic
of applying each operator in the body of a single function.  In <tt class="docutils literal">calc_apply</tt>,
each conditional clause corresponds to applying one operator.</p>
<pre class="doctest-block">
&gt;&gt;&gt; from operator import mul
&gt;&gt;&gt; from functools import reduce
&gt;&gt;&gt; def calc_apply(operator, args):
        &quot;&quot;&quot;Apply the named operator to a list of args.&quot;&quot;&quot;
        if operator in ('add', '+'):
            return sum(args)
        if operator in ('sub', '-'):
            if len(args) == 0:
                raise TypeError(operator + ' requires at least 1 argument')
            if len(args) == 1:
                return -args[0]
            return sum(args[:1] + [-arg for arg in args[1:]])
        if operator in ('mul', '*'):
            return reduce(mul, args, 1)
        if operator in ('div', '/'):
            if len(args) != 2:
                raise TypeError(operator + ' requires exactly 2 arguments')
            numer, denom = args
            return numer/denom
</pre>
<p>Above, each suite computes the result of a different operator, or raises an
appropriate <tt class="docutils literal">TypeError</tt> when the wrong number of arguments is given. The
<tt class="docutils literal">calc_apply</tt> function can be applied directly, but it must be passed a list
of <em>values</em> as arguments rather than a list of operand expressions.</p>
<pre class="doctest-block">
&gt;&gt;&gt; calc_apply('+', [1, 2, 3])
6
&gt;&gt;&gt; calc_apply('-', [10, 1, 2, 3])
4
&gt;&gt;&gt; calc_apply('*', [])
1
&gt;&gt;&gt; calc_apply('/', [40, 5])
8.0
</pre>
<p>The role of <tt class="docutils literal">calc_eval</tt> is to make proper calls to <tt class="docutils literal">calc_apply</tt> by first
computing the value of operand sub-expressions before passing them as arguments
to <tt class="docutils literal">calc_apply</tt>. Thus, <tt class="docutils literal">calc_eval</tt> can accept a nested expression.</p>
<pre class="doctest-block">
&gt;&gt;&gt; e = Exp('add', [2, Exp('mul', [4, 6])])
&gt;&gt;&gt; str(e)
'add(2, mul(4, 6))'
&gt;&gt;&gt; calc_eval(e)
26
</pre>
<p>The structure of <tt class="docutils literal">calc_eval</tt> is an example of dispatching on type: the form
of the expression. The first form of expression is a number, which requires no
additional evaluation step. In general, primitive expressions that do not
require an additional evaluation step are called <em>self-evaluating</em>. The only
self-evaluating expressions in our Calculator language are numbers, but a
general programming language might also include strings, boolean values, etc.</p>
<p><strong>Read-eval-print loops.</strong> A typical approach to interacting with an
interpreter is through a read-eval-print loop, or REPL, which is a mode of
interaction that reads an expression, evaluates it, and prints the result for
the user.  The Python interactive session is an example of such a loop.</p>
<p>An implementation of a REPL can be largely independent of the interpreter it
uses. The function <tt class="docutils literal">read_eval_print_loop</tt> below takes as input a line of text
from the user with the built-in <tt class="docutils literal">input</tt> function. It constructs an expression
tree using the language-specific <tt class="docutils literal">calc_parse</tt> function, defined in the
following section on parsing. Finally, it prints the result of applying
<tt class="docutils literal">calc_eval</tt> to the expression tree returned by <tt class="docutils literal">calc_parse</tt>.</p>
<pre class="doctest-block">
&gt;&gt;&gt; def read_eval_print_loop():
        &quot;&quot;&quot;Run a read-eval-print loop for calculator.&quot;&quot;&quot;
        while True:
            expression_tree = calc_parse(input('calc&gt; '))
            print(calc_eval(expression_tree))
</pre>
<p>This version of <tt class="docutils literal">read_eval_print_loop</tt> contains all of the essential
components of an interactive interface.  An example session would look like:</p>
<pre class="literal-block">
calc&gt; mul(1, 2, 3)
6
calc&gt; add()
0
calc&gt; add(2, div(4, 8))
2.5
</pre>
<p>This loop implementation has no mechanism for termination or error handling.
We can improve the interface by reporting errors to the user. We can also allow
the user to exit the loop by signalling a keyboard interrupt (<tt class="docutils literal"><span class="pre">Control-C</span></tt> on
UNIX) or end-of-file exception (<tt class="docutils literal"><span class="pre">Control-D</span></tt> on UNIX). To enable these
improvements, we place the original suite of the <tt class="docutils literal">while</tt> statement within a
<tt class="docutils literal">try</tt> statement.  The first <tt class="docutils literal">except</tt> clause handles <tt class="docutils literal">SyntaxError</tt>
exceptions raised by <tt class="docutils literal">calc_parse</tt> as well as <tt class="docutils literal">TypeError</tt> and
<tt class="docutils literal">ZeroDivisionError</tt> exceptions raised by <tt class="docutils literal">calc_eval</tt>.</p>
<pre class="doctest-block">
&gt;&gt;&gt; def read_eval_print_loop():
        &quot;&quot;&quot;Run a read-eval-print loop for calculator.&quot;&quot;&quot;
        while True:
            try:
                expression_tree = calc_parse(input('calc&gt; '))
                print(calc_eval(expression_tree))
            except (SyntaxError, TypeError, ZeroDivisionError) as err:
                print(type(err).__name__ + ':', err)
            except (KeyboardInterrupt, EOFError):  # &lt;Control&gt;-D, etc.
                print('Calculation completed.')
                return
</pre>
<p>This loop implementation reports errors without exiting the loop.  Rather than
exiting the program on an error, restarting the loop after an error message
lets users revise their expressions. Upon importing the <tt class="docutils literal">readline</tt> module,
users can even recall their previous inputs using the up arrow or
<tt class="docutils literal"><span class="pre">Control-P</span></tt>. The final result provides an informative error reporting
interface:</p>
<pre class="literal-block">
calc&gt; add
SyntaxError: expected ( after add
calc&gt; div(5)
TypeError: div requires exactly 2 arguments
calc&gt; div(1, 0)
ZeroDivisionError: division by zero
calc&gt; ^DCalculation completed.
</pre>
<p>As we generalize our interpreter to new languages other than Calculator, we
will see that the <tt class="docutils literal">read_eval_print_loop</tt> is parameterized by a parse
function, an evaluation function, and the exception types handled by the <tt class="docutils literal">try</tt>
statement.  Beyond these changes, all REPLs can be implemented using the same
structure.</p>
</div>
<div class="section" id="parsing">
<h2><a class="toc-backref" href="#id21">3.5.2&nbsp;&nbsp;&nbsp;Parsing</a></h2>
<p>Parsing is the process of generating expression trees from raw text
input. It is the job of the evaluation function to interpret those expression
trees, but the parser must supply well-formed expression trees to the
evaluator. A parser is in fact a composition of two components: a lexical
analyzer and a syntactic analyzer.  First, the lexical analyzer partitions
the input string into <em>tokens</em>, which are the minimal syntactic units of the
language, such as names and symbols. Second, the syntactic analyzer constructs
an expression tree from this sequence of tokens.</p>
<pre class="doctest-block">
&gt;&gt;&gt; def calc_parse(line):
        &quot;&quot;&quot;Parse a line of calculator input and return an expression tree.&quot;&quot;&quot;
        tokens = tokenize(line)
        expression_tree = analyze(tokens)
        if len(tokens) &gt; 0:
            raise SyntaxError('Extra token(s): ' + ' '.join(tokens))
        return expression_tree
</pre>
<p>The sequence of tokens produced by the lexical analyzer, called <tt class="docutils literal">tokenize</tt>,
is consumed by the syntactic analyzer, called <tt class="docutils literal">analyze</tt>.  In this case, we
define <tt class="docutils literal">calc_parse</tt> to expect only one well-formed Calculator expression.
Parsers for some languages are designed to accept multiple expressions
delimited by new line characters, semicolons, or even spaces. We defer this
additional complexity until we introduce the Logo language below.</p>
<p><strong>Lexical analysis.</strong> The component that interprets a string as a token
sequence is called a <em>tokenizer</em> or <em>lexical analyzer</em>. In our implementation,
the tokenizer is a function called <tt class="docutils literal">tokenize</tt>. The Calculator language
consists of symbols that include numbers, operator names, and operator symbols,
such as <tt class="docutils literal">+</tt>.  These symbols are always separated by two types of delimiters:
commas and parentheses. Each symbol is its own token, as is each comma and
parenthesis.  Tokens can be separated by adding spaces to the input string and
then splitting the string at each space.</p>
<pre class="doctest-block">
&gt;&gt;&gt; def tokenize(line):
        &quot;&quot;&quot;Convert a string into a list of tokens.&quot;&quot;&quot;
        spaced = line.replace('(',' ( ').replace(')',' ) ').replace(',', ' , ')
        return spaced.split()
</pre>
<p>Tokenizing a well-formed Calculator expression keeps names intact, but
separates all symbols and delimiters.</p>
<pre class="doctest-block">
&gt;&gt;&gt; tokenize('add(2, mul(4, 6))')
['add', '(', '2', ',', 'mul', '(', '4', ',', '6', ')', ')']
</pre>
<p>Languages with a more complicated syntax may require a more sophisticated
tokenizer.  In particular, many tokenizers resolve the syntactic type of each
token returned. For example, the type of a token in Calculator may be an
operator, a name, a number, or a delimiter. This classification can simplify
the process of <em>parsing</em> the token sequence.</p>
<p><strong>Syntactic analysis.</strong> The component that interprets a token sequence as an
expression tree is called a <em>syntactic analyzer</em>. In our implementation,
syntactic analysis is performed by a recursive function called <tt class="docutils literal">analyze</tt>. It
is recursive because analyzing a sequence of tokens often involves analyzing a
subsequence of those tokens into an expression tree, which itself serves as a
branch (i.e., operand) of a larger expression tree. Recursion generates the
hierarchical structures consumed by the evaluator.</p>
<p>The <tt class="docutils literal">analyze</tt> function expects a list of tokens that begins with a
well-formed expression.  It analyzes the first token, coercing strings that
represent numbers into numeric values.  It then must consider the two legal
expression types in the Calculator language. Numeric tokens are themselves
complete, primitive expression trees. Combined expressions begin with an
operator and follow with a list of operand expressions delimited by
parentheses. Operands are analyzed by the <tt class="docutils literal">analyze_operands</tt> function, which
recursively calls <tt class="docutils literal">analyze</tt> on each operand expression. We begin with an
implementation that does not check for syntax errors.</p>
<pre class="doctest-block">
&gt;&gt;&gt; def analyze(tokens):
        &quot;&quot;&quot;Create a tree of nested lists from a sequence of tokens.&quot;&quot;&quot;
        token = analyze_token(tokens.pop(0))
        if type(token) in (int, float):
            return token
        else:
            tokens.pop(0)  # Remove (
            return Exp(token, analyze_operands(tokens))
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; def analyze_operands(tokens):
        &quot;&quot;&quot;Read a list of comma-separated operands.&quot;&quot;&quot;
        operands = []
        while tokens[0] != ')':
            if operands:
                tokens.pop(0)  # Remove ,
            operands.append(analyze(tokens))
        tokens.pop(0)  # Remove )
        return operands
</pre>
<p>Finally, we need to implement <tt class="docutils literal">analyze_token</tt>. The <tt class="docutils literal">analyze_token</tt> function
that converts number literals into numbers.  Rather than implementing this
logic ourselves, we rely on built-in Python type coercion, using the <tt class="docutils literal">int</tt>
and <tt class="docutils literal">float</tt> constructors to convert tokens to those types.</p>
<pre class="doctest-block">
&gt;&gt;&gt; def analyze_token(token):
        &quot;&quot;&quot;Return the value of token if it can be analyzed as a number, or token.&quot;&quot;&quot;
        try:
            return int(token)
        except (TypeError, ValueError):
            try:
                return float(token)
            except (TypeError, ValueError):
                return token
</pre>
<p>Our implementation of <tt class="docutils literal">analyze</tt> is complete; it correctly parses well-formed
Calculator expressions into expression trees. These trees can be converted back
into Calculator expressions by the <tt class="docutils literal">str</tt> function.</p>
<pre class="doctest-block">
&gt;&gt;&gt; expression = 'add(2, mul(4, 6))'
&gt;&gt;&gt; analyze(tokenize(expression))
Exp('add', [2, Exp('mul', [4, 6])])
&gt;&gt;&gt; str(analyze(tokenize(expression)))
'add(2, mul(4, 6))'
</pre>
<p>The <tt class="docutils literal">analyze</tt> function is meant to return only well-formed expression trees,
and so it must detect errors in the syntax of its input. In particular, it must
detect that expressions are complete, correctly delimited, and use only known
operators.  The following revisions ensure that each step of the syntactic
analysis finds the token it expects.</p>
<pre class="doctest-block">
&gt;&gt;&gt; known_operators = ['add', 'sub', 'mul', 'div', '+', '-', '*', '/']
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; def analyze(tokens):
        &quot;&quot;&quot;Create a tree of nested lists from a sequence of tokens.&quot;&quot;&quot;
        assert_non_empty(tokens)
        token = analyze_token(tokens.pop(0))
        if type(token) in (int, float):
            return token
        if token in known_operators:
            if len(tokens) == 0 or tokens.pop(0) != '(':
                raise SyntaxError('expected ( after ' + token)
            return Exp(token, analyze_operands(tokens))
        else:
            raise SyntaxError('unexpected ' + token)
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; def analyze_operands(tokens):
        &quot;&quot;&quot;Analyze a sequence of comma-separated operands.&quot;&quot;&quot;
        assert_non_empty(tokens)
        operands = []
        while tokens[0] != ')':
            if operands and tokens.pop(0) != ',':
                raise SyntaxError('expected ,')
            operands.append(analyze(tokens))
            assert_non_empty(tokens)
        tokens.pop(0)  # Remove )
        return elements
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; def assert_non_empty(tokens):
        &quot;&quot;&quot;Raise an exception if tokens is empty.&quot;&quot;&quot;
        if len(tokens) == 0:
            raise SyntaxError('unexpected end of line')
</pre>
<p>Informative syntax errors improve the usability of an interpreter
substantially. Above, the <tt class="docutils literal">SyntaxError</tt> exceptions that are raised include
a description of the problem encountered.  These error strings also serve to
document the definitions of these analysis functions.</p>
<p>This definition completes our Calculator interpreter.  A single Python 3 source
file <a class="reference external" href="calc.py">calc.py</a> is available for your experimentation. Our
interpreter is robust to errors, in the sense that every input that a user
enters at the <tt class="docutils literal">calc&gt;</tt> prompt will either be evaluated to a number or raise an
appropriate error that describes why the input is not a well-formed Calculator
expression.</p>
</div>
</div>
<div class="section" id="interpreters-for-languages-with-abstraction">
<h1><a class="toc-backref" href="#id22">3.6&nbsp;&nbsp;&nbsp;Interpreters for Languages with Abstraction</a></h1>
<p>The Calculator language provides a means of combination through nested call
expressions. However, there is no way to define new operators, give names to
values, or express general methods of computation. In summary, Calculator does
not support abstraction in any way. As a result, it is not a particularly
powerful or general programming language. We now turn to the task of defining a
general programming language that supports abstraction by binding names to
values and defining new operations.</p>
<p>Rather than extend our simple Calculator language further, we will begin anew
and develop an interpreter for the Logo language. Logo is not a language
invented for this course, but instead a classic instructional language with
dozens of interpreter implementations and its own developer community.</p>
<p>Unlike the previous section, which presented a complete interpreter as Python
source code, this section takes a descriptive approach. The companion project
asks you to implement the ideas presented here by building a fully functional
Logo interpreter.</p>
<div class="section" id="the-scheme-language">
<span id="scheme-language"></span><h2><a class="toc-backref" href="#id23">3.6.1&nbsp;&nbsp;&nbsp;The Scheme Language</a></h2>
<p>Scheme is a dialect of Lisp, the second-oldest programming language that is still
widely used today (after Fortran). Scheme was first described in 1975 by
Gerald Sussman and Guy Steele.  From the introduction to the
<em>`Revised(4) Report on the Algorithmic Language Scheme`_</em>,</p>
<blockquote>
Programming languages should be designed not by piling feature on top
of feature, but by removing the weaknesses and restrictions that make
additional features appear necessary. Scheme demonstrates that a very
small number of rules for forming expressions, with no restrictions on
how they are composed, suffice to form a practical and efficient
programming language that is flexible enough to support most of the
major programming paradigms in use today.</blockquote>
<p>We refer you to this Report for full details of the Scheme language.
We'll touch on highlights here.  We've used examples from
the Report in the descriptions below..</p>
<p>Despite its simplicity, Scheme is a real programming language and in many ways
is similar to Python, but with a minimum of &quot;syntactic sugar&quot;<a class="footnote-reference" href="#id2" id="id1">[1]</a>.  Basically,
<em>all</em> operations take the form of function calls.
Here, we will describe a representative subset of the full Scheme language
described in the report.</p>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Regrettably, this has become less true in more recent revisions of
the Scheme language, such as the <em>Revised(6) Report</em>, so here, we'll
stick with previous versions.</td></tr>
</tbody>
</table>
<p>There are several implementations of Scheme available, which add on various
additional procedures.  At Berkeley, we've used a
<a class="reference external" href="http://inst.eecs.berkeley.edu/~scheme/">modified version of the Stk interpreter</a>,
which is also available as <tt class="docutils literal">stk</tt> on our instructional servers.
Unfortunately, it is not particularly conformant to the official specification,
but it will do for our purposes.</p>
<p><strong>Using the Interpreter.</strong>
As with the Python interpreter[#], expressions typed to the Stk interpreter
are evaluated and printed by what is known as a <em>read-eval-print loop</em>:</p>
<pre class="literal-block">
&gt;&gt;&gt; 3
3
&gt;&gt;&gt; (- (/ (* (+ 3 7 10) (- 1000 8)) 992) 17)
3
&gt;&gt;&gt; (define (fib n) (if (&lt; n 2) n (+ (fib (- n 2)) (fib (- n 1)))))
fib
&gt;&gt;&gt; '(1 (7 19))
(1 (7 19))
</pre>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td>In our examples, we use the same notation as for Python: <tt class="docutils literal">&gt;&gt;&gt;</tt> and
<tt class="docutils literal">...</tt> to indicate lines input to the interpreter and unprefixed
lines to indicate output.  In reality, Scheme interpreters use
different prompts.  STk, for example, prompts with <tt class="docutils literal">STk&gt;</tt> and
does not prompt for continuation lines.  The Python conventions,
however, make it clearer what is input and what is output.</td></tr>
</tbody>
</table>
<p><strong>Values in Scheme.</strong>
Values in Scheme generally have their counterparts in Python.</p>
<blockquote>
<dl class="docutils">
<dt>Booleans</dt>
<dd>The values true and false, denoted <tt class="docutils literal">#t</tt> and <tt class="docutils literal">#f</tt>.  In
Scheme, the only false value (in the Python sense) is <tt class="docutils literal">#f</tt>.</dd>
<dt>Numbers</dt>
<dd>These include integers of arbitrary precision, rational numbers,
complex numbers, and &quot;inexact&quot; (generally floating-point) numbers.
Integers may be denoted either in standard decimal notation or
in other radixes by prefixing a numeral with <tt class="docutils literal">#o</tt> (octal),
<tt class="docutils literal">#x</tt> (hexadecimal), or <tt class="docutils literal">#b</tt> (binary).</dd>
<dt>Symbols</dt>
<dd><p class="first">Symbols are a kind of string, but are denoted without quotation marks.
The valid characters include letters, digits, and:</p>
<pre class="literal-block">
!  $  %  &amp;  *  /  :  &lt;  = &gt;  ?  ^  _  ~  +  -  .  &#64;
</pre>
<p class="last">When input by the <tt class="docutils literal">read</tt> function, which reads Scheme expressions
(and which the interpreter uses to input program text), upper and
lower case characters in symbols are not distinguished (in the STk
implementation, converted to lower case).
Two symbols with the same denotation denote
the same object (not just two objects that happen to have the same
contents).</p>
</dd>
<dt>Pairs and Lists</dt>
<dd><p class="first">A pair is an object containing two components (of any types), called
its <tt class="docutils literal">car</tt> and <tt class="docutils literal">cdr</tt>.  A pair whose <tt class="docutils literal">car</tt> is <tt class="docutils literal">A</tt> and whose
<tt class="docutils literal">cdr</tt> is <tt class="docutils literal">B</tt> is denoted <tt class="docutils literal">(A . B)</tt>.  Pairs (like tuples in
Python) can represent lists, trees, and arbitrary hierarchical
structures.</p>
<p>A standard Scheme list consists either of the special empty
list value (denoted ()), or of a pair that contains the first item of
the list as its <tt class="docutils literal">car</tt> and the rest of the list as its <tt class="docutils literal">cdr</tt>.
Thus, the list consisting of the integers 1, 2, and 3 would be
represented:</p>
<pre class="literal-block">
(1 . (2 . (3 . ())))
</pre>
<p>Lists are so pervasive that Scheme allows one to abbreviate
<tt class="docutils literal">(a . ())</tt> as <tt class="docutils literal">(a)</tt>, and allows one to abbreviate <tt class="docutils literal">(a . (b <span class="pre">...))</span></tt>
as <tt class="docutils literal">(a b <span class="pre">...)</span></tt>.  Thus, the list above is usually written:</p>
<pre class="last literal-block">
(1 2 3)
</pre>
</dd>
<dt>Procedures (functions)</dt>
<dd>As in Python, a procedure (or function) value represents some
computation that can be invoked by a function call supplying
argument values.  Procedures may either be primitives, supplied
by the Scheme runtime system, or they may be constructed out of
Scheme expression(s) and an environment (exactly as in Python).
There is no direct denotation for function values,
although there
are predefined identifiers that are bound to primitive
functions and there are Scheme expressions that, when evaluated,
produce new procedure values.</dd>
<dt>Other Types</dt>
<dd>Scheme also supports characters and strings (like Python strings,
except that Scheme distinguishes characters from strings),
and vectors (like Python lists).</dd>
</dl>
</blockquote>
<p><strong>Program Denotations</strong>
As with other versions of Lisp, Scheme's data values double as representations
of programs.  For example, the Scheme list:</p>
<pre class="literal-block">
(+ x (* 10 y))
</pre>
<p>can, depending on how it is used, represent either a 3-item list (whose last
item is also a 3-item list), or it can represent a Scheme expression for
computing \(x+10y\).  To interpret a Scheme value as a program, we consider
the type of value, and evaluate as follows:</p>
<blockquote>
<ul class="simple">
<li>Integers, booleans, characters, strings, and vectors
evaluate to themselves.  Thus,
the expression <tt class="docutils literal">5</tt> evaluates to 5.</li>
<li>Bare symbols serve as variables.  Their values are determined by the
current environment in which they are being evaluated, just as in
Python.</li>
<li>Non-empty lists are interpreted in two different ways, depending on their
first component:<ul>
<li>If the first component is one of the symbols denoting a <em>special form</em>,
described below, the evaluation proceeds by the rules for that special
form.</li>
<li>In all other cases (called <em>combinations</em>),
the items in the list are evaluated (recursively) in some unspecified
order.
The value of the first item must be a function value.  That value is
called, with the values of the remaining items in the list supplying
the arguments.</li>
</ul>
</li>
<li>Other Scheme values (in particular, pairs that are not lists) are
erroneous as programs.</li>
</ul>
</blockquote>
<p>For example:</p>
<pre class="literal-block">
&gt;&gt;&gt; 5              ; A literal.
5
&gt;&gt;&gt; (define x 3)   ; A special form that creates a binding for symbol
x                   ; x.
&gt;&gt;&gt; (+ 3 (* 10 x)) ; A combination.  Symbol + is bound to the primitive
33                  ; add function and * to primitive multiply.
</pre>
<p><strong>Primitive Special Forms.</strong>
The special forms denote things such as control structures,
function definitions, or class definitions in Python: constructs in which the
operands are not simply evaluated immediately, as they are in calls.</p>
<p>First, a couple of common constructs used in the forms:</p>
<blockquote>
<dl class="docutils">
<dt><em>EXPR-SEQ</em></dt>
<dd><p class="first">Simply a sequence of expressions, such as:</p>
<pre class="literal-block">
(+ 3 2) x (* y z)
</pre>
<p class="last">When this appears in the definitions below, it refers to a sequence
of expressions that are evaluated from left to right, with the
value of the sequence (if needed) being the value of the last
expression.</p>
</dd>
<dt><em>BODY</em></dt>
<dd>Several constructs have &quot;bodies&quot;, which are <em>EXPR-SEQ</em>s, as above,
optionally preceded by one or more <a class="reference internal" href="#definitions">Definitions</a>.
Their value is that
of their <em>EXPR-SEQ</em>.  See the section on <a class="reference internal" href="#internal-definitions">Internal Definitions</a>
for the interpretation of these definitions.</dd>
</dl>
</blockquote>
<p>Here is a representative subset of the special forms:</p>
<blockquote id="definitions">
<dl class="docutils">
<dt>Definitions</dt>
<dd><p class="first">Definitions may appear either at the top level
of a program (that is, not enclosed in another construct).</p>
<blockquote class="last">
<dl class="docutils">
<dt>(define <em>SYM</em> <em>EXPR</em>)</dt>
<dd>This evaluates <em>EXPR</em> and binds its value to the symbol <em>SYM</em> in the
current environment.</dd>
<dt>(define (<em>SYM</em> <em>ARGUMENTS</em>) <em>BODY</em>)</dt>
<dd><p class="first">This is equivalent to</p>
<blockquote class="last">
<div class="line-block">
<div class="line">(define <em>SYM</em> (lambda (<em>ARGUMENTS</em>) <em>BODY</em>))</div>
</div>
</blockquote>
</dd>
</dl>
</blockquote>
</dd>
<dt>(lambda (<em>ARGUMENTS</em>) <em>BODY</em>)</dt>
<dd><p class="first">This evaluates to a function.  <em>ARGUMENTS</em> is usually
a list (possibly empty) of distinct symbols that gives names
to the arguments of the function, and indicates their number.
It is also possible for <em>ARGUMENTS</em> to have the form:</p>
<pre class="literal-block">
(sym1 sym2 ... symn . symr)
</pre>
<p>(that is, instead of ending in the empty list like a normal list,
the last <tt class="docutils literal">cdr</tt> is a symbol).  In this case, <tt class="docutils literal">symr</tt> will be bound
to the list of trailing argument values (argument n+1 onward).</p>
<p class="last">When the resulting function is called, <em>ARGUMENTS</em> are bound to the
argument values in a fresh environment frame that extends the
environment in which the <tt class="docutils literal">lambda</tt> expression was evaluated (just
like Python).
Then the <em>BODY</em> is evaluated and its value returned as
the value of the call.</p>
</dd>
<dt>(if <em>COND-EXPR</em> <em>TRUE-EXPR</em> <em>OPTIONAL-FALSE-EXPR</em>)</dt>
<dd>Evaluates <em>COND-EXPR</em>, and if its value is not <tt class="docutils literal">#f</tt>, then
evaluates  <em>TRUE-EXPR</em>, and the result is the value of the <tt class="docutils literal">if</tt>.
If <em>COND-EXPR</em> evaluates to <tt class="docutils literal">#f</tt> and
<em>OPTIONAL-FALSE-EXPR</em> is present, it is evaluated and its result
is the value of the <tt class="docutils literal">if</tt>.  If it is absent, the value of
the <tt class="docutils literal">if</tt> is unspecified.</dd>
<dt>(set! <em>SYMBOL</em> <em>EXPR</em>)</dt>
<dd>Evaluates <em>EXPR</em> and replaces the binding of <em>SYMBOL</em> with the
resulting value.  <em>SYMBOL</em> must be bound, or there is an error.
In contrast to Python's default,
this replaces the binding of <em>SYMBOL</em> in
the first enclosing environment frame that defines it, which is not
always the innermost frame.</dd>
<dt>(quote <em>EXPR</em>)  or  '<em>EXPR</em></dt>
<dd><p class="first">One problem with using Scheme data structures as program representations
is that one needs a way to indicate when a particular symbol or list
represents literal data to be manipulated by a program, and when it is
program text that is intended to be evaluated.  The <tt class="docutils literal">quote</tt> form
evaluates to <em>EXPR</em> itself, without further evaluating <em>EXPR</em>.
(The alternative form, with leading apostrophe, gets converted to
the first form by Scheme's expression reader.)  For example:</p>
<pre class="last literal-block">
&gt;&gt;&gt; (+ 1 2)
3
&gt;&gt;&gt; '(+ 1 2)
(+ 1 2)
&gt;&gt;&gt; (define x 3)
x
&gt;&gt;&gt; x
3
&gt;&gt;&gt; (quote x)
x
&gt;&gt;&gt; '5
5
&gt;&gt;&gt; (quote 'x)
(quote x)
</pre>
</dd>
</dl>
</blockquote>
<p><strong>Derived Special Forms</strong></p>
<p>A <em>derived construct</em> is one that can be translated into primitive constructs.
Their purpose is to make programs more concise or clear for the reader.
In Scheme, we have</p>
<blockquote>
<dl class="docutils">
<dt>(begin <em>EXPR-SEQ</em>)</dt>
<dd>Simply evaluates and yields the value of the <em>EXPR-SEQ</em>.
This construct is simply a way to execute a sequence of expressions in
a context (such as an <tt class="docutils literal">if</tt>) that requires a single expression.</dd>
<dt>(and <em>EXPR1</em> <em>EXPR2</em> ...)</dt>
<dd><p class="first">Each <em>EXPR</em> is evaluated from left to right until one returns
<tt class="docutils literal">#f</tt> or the <em>EXPR</em>s are exhausted. The value is that of the last
<em>EXPR</em> evaluated, or <tt class="docutils literal">#t</tt> if the list of <em>EXPR</em>s is empty.
For example:</p>
<pre class="last literal-block">
&gt;&gt;&gt; (and (= 2 2) (&gt; 2 1))
#t
&gt;&gt;&gt; (and (&lt; 2 2) (&gt; 2 1))
#f
&gt;&gt;&gt; (and (= 2 2) '(a b))
(a b)
&gt;&gt;&gt; (and)
#t
</pre>
</dd>
<dt>(or <em>EXPR1</em> <em>EXPR2</em> ...)</dt>
<dd><p class="first">Each <em>EXPR</em> is evaluated from left to right until one returns
a value other than <tt class="docutils literal">#f</tt> or the <em>EXPR</em>s are exhausted.
The value is that of the last <em>EXPR</em> evaluated, or <tt class="docutils literal">#f</tt> if
the list of <em>EXPR</em>s is empty:  For example:</p>
<pre class="last literal-block">
&gt;&gt;&gt; (or (= 2 2) (&gt; 2 3))
#t
&gt;&gt;&gt; (or (= 2 2) '(a b))
#t
&gt;&gt;&gt; (or (&gt; 2 2) '(a b))
(a b)
&gt;&gt;&gt; (or (&gt; 2 2) (&gt; 2 3))
#f
&gt;&gt;&gt; (or)
#f
</pre>
</dd>
<dt>(cond <em>CLAUSE1</em> <em>CLAUSE2</em> ...)</dt>
<dd><p class="first">Each <em>CLAUSEi</em> is processed in turn until one succeeds, and its
value becomes the value of the <tt class="docutils literal">cond</tt>. If no clause succeeds, the
value is unspecified.  Each clause has one of three possible forms.
The form</p>
<blockquote>
<div class="line-block">
<div class="line">(<em>TEST-EXPR</em> <em>EXPR-SEQ</em>)</div>
</div>
</blockquote>
<p>succeeds if <em>TEST-EXPR</em> evaluates to a value other than <tt class="docutils literal">#f</tt>.  In
that case, it evaluates <em>EXPR-SEQ</em> and yields its value.  The <em>EXPR-SEQ</em>
may be omitted, in which case the value is that of <em>TEST-EXPR</em> itself.</p>
<p>The last clause may have the form</p>
<blockquote>
<div class="line-block">
<div class="line">(else <em>EXPR-SEQ</em>)</div>
</div>
</blockquote>
<p>which is equivalent to</p>
<blockquote>
<div class="line-block">
<div class="line">(#t <em>EXPR-SEQ</em>)</div>
</div>
</blockquote>
<p>Finally, the form</p>
<blockquote>
<div class="line-block">
<div class="line">(<em>TEST_EXPR</em> =&gt; <em>EXPR</em>)</div>
</div>
</blockquote>
<p>succeeds if <em>TEST_EXPR</em> evaluates to a value other than <tt class="docutils literal">#f</tt>, call
it <em>V</em>.  If it succeeds, the value of the <tt class="docutils literal">cond</tt> construct is that
returned by (<em>EXPR</em> <em>V</em>).  That is, <em>EXPR</em> must evaluate to a
one-argument function, which is applied to the value of <em>TEST_EXPR</em>.</p>
<p>For example:</p>
<pre class="last literal-block">
&gt;&gt;&gt; (cond ((&gt; 3 2) 'greater)
...        ((&lt; 3 2) 'less)))
greater
&gt;&gt;&gt; (cond ((&gt; 3 3) 'greater)
...        ((&lt; 3 3) 'less)
...        (else 'equal))
equal
&gt;&gt;&gt; (cond ((if (&lt; -2 -3) #f -3) =&gt; abs)
...        (else #f))
3
</pre>
</dd>
<dt>(case <em>KEY-EXPR</em> <em>CLAUSE1</em> <em>CLAUSE2</em> ...)</dt>
<dd><p class="first">Evaluates <em>KEY-EXPR</em> to produce a value, <em>K</em>.  Then matches <em>K</em>
against each <em>CLAUSE1</em> in turn until one succeeds, and returns
the value of that clause.  If no clause succeeds, the value is
unspecified.  Each clause has the form</p>
<blockquote>
<div class="line-block">
<div class="line">((<em>DATUM1</em> <em>DATUM2</em> ...) <em>EXPR-SEQ</em>)</div>
</div>
</blockquote>
<p>The <em>DATUM</em>s are Scheme values (they are <em>not</em> evaluated).  The
clause succeeds if <em>K</em> matches one of the <em>DATUM</em> values (as
determined by the <tt class="docutils literal">eqv?</tt> function described below.)  If the
clause succeeds, its <em>EXPR-SEQ</em> is evaluated and its value becomes
the value of the <tt class="docutils literal">case</tt>.  The last clause
may have the form</p>
<blockquote>
<div class="line-block">
<div class="line">(else <em>EXPR-SEQ</em>)</div>
</div>
</blockquote>
<p>which always succeeds.  For example:</p>
<pre class="last literal-block">
&gt;&gt;&gt; (case (* 2 3)
...     ((2 3 5 7) 'prime)
...     ((1 4 6 8 9) 'composite))
composite
&gt;&gt;&gt; (case (car '(a . b))
...     ((a c) 'd)
...     ((b 3) 'e))
d
&gt;&gt;&gt; (case (car '(c d))
...    ((a e i o u) 'vowel)
...    ((w y) 'semivowel)
...    (else 'consonant))
consonant
</pre>
</dd>
<dt>(let <em>BINDINGS</em> <em>BODY</em>)</dt>
<dd><p class="first"><em>BINDINGS</em> is a list of pairs of the form</p>
<blockquote>
<div class="line-block">
<div class="line">( (<em>VAR1</em> <em>INIT1</em>) (<em>VAR2</em> <em>INIT2</em>) ...)</div>
</div>
</blockquote>
<p>where the <em>VAR</em>s are (distinct) symbols and the <em>INIT</em>s are
expressions.  This first evaluates the <em>INIT</em> expressions, then
creates a new frame that binds those values to the <em>VAR</em>s, and then
evaluates the <em>BODY</em> in that new environment,
returning its value.  In other words, this is equivalent to
the call</p>
<blockquote>
<div class="line-block">
<div class="line">((lambda (<em>VAR1</em> <em>VAR2</em> ...) <em>BODY</em>)</div>
<div class="line-block">
<div class="line"><em>INIT1</em> <em>INIT2</em> ...)</div>
</div>
</div>
</blockquote>
<p>Thus, any references to the <em>VAR</em>s in the <em>INIT</em> expressions refers
to the definitions (if any) of those symbols <em>outside</em> of the <tt class="docutils literal">let</tt>
construct. For example:</p>
<pre class="last literal-block">
&gt;&gt;&gt; (let ((x 2) (y 3))
...       (* x y))
6
&gt;&gt;&gt; (let ((x 2) (y 3))
...       (let ((x 7) (z (+ x y)))
...            (* z x)))
35
</pre>
</dd>
<dt>(let* <em>BINDINGS</em> <em>BODY</em>)</dt>
<dd><p class="first">The syntax of <em>BINDINGS</em> is the same as for <tt class="docutils literal">let</tt>.  This is equivalent
to</p>
<blockquote>
<div class="line-block">
<div class="line">(let ((<em>VAR1</em> <em>INIT1</em>))</div>
<div class="line-block">
<div class="line">...</div>
<div class="line">(let ((<em>VARn</em> <em>INITn</em>))</div>
<div class="line-block">
<div class="line"><em>BODY</em>))</div>
</div>
</div>
</div>
</blockquote>
<p>In other words, it is like <tt class="docutils literal">let</tt> except that the new binding of <em>VAR1</em>
is visible in subsequent <em>INIT</em>s as well as in the <em>BODY</em>, and
similarly for <em>VAR2</em>.  For example:</p>
<pre class="last literal-block">
&gt;&gt;&gt; (define x 3)
x
&gt;&gt;&gt; (define y 4)
y
&gt;&gt;&gt; (let ((x 5) (y (+ x 1))) y)
4
&gt;&gt;&gt; (let* ((x 5) (y (+ x 1))) y)
6
</pre>
</dd>
<dt>(<span class="target" id="letrec">letrec</span> <em>BINDINGS</em> <em>BODY</em>)</dt>
<dd><p class="first">Again, the syntax is as for <tt class="docutils literal">let</tt>.  In this case, the new bindings
are all created first (with undefined values) and then the
<em>INIT</em>s are evaluated and assigned to them.  It is undefined what
happens if one of the <em>INIT</em>s uses the value of a <em>VAR</em> that has not had an
initial value assigned yet.  This form is intended mostly for defining
mutually recursive functions (lambdas do not, by themselves, use the
values of the variables they mention; that only happens later, when
they are called.  For example:</p>
<pre class="last literal-block">
                                                                             (letrec ((even?
      (lambda (n)
             (if (zero? n)
                  #t
                  (odd? (- n 1)))))
     (odd?
      (lambda (n)
              (if (zero? n)
                  #f
                  (even? (- n 1))))))
(even? 88))
</pre>
</dd>
</dl>
</blockquote>
<p id="internal-definitions"><strong>Internal Definitions.</strong>  When a <em>BODY</em> begins with a sequence of <tt class="docutils literal">define</tt>
constructs, they are known as &quot;internal definitions&quot; and are interpreted a
little differently from top-level definitions.  Specifically, they work like
<a class="reference internal" href="#letrec">letrec</a> does.</p>
<blockquote>
<ul class="simple">
<li>First, bindings are created for all the names defined by the
<tt class="docutils literal">define</tt> statements, initially bound to undefined values.</li>
<li>Then
the values are filled in by the defines.</li>
</ul>
</blockquote>
<p>As a result, a sequence of
internal function definitions can be mutually recursive, just as <tt class="docutils literal">def</tt>
statements in Python that are nested inside a function can be:</p>
<pre class="literal-block">
&gt;&gt;&gt; (define (hard-even? x)     ;; An outer-level definition
...      (define (even? n)      ;; Inner definition
...          (if (zero? n)
...              #t
...              (odd? (- n 1))))
...      (define (odd? n)       ;; Inner definition
...          (if (zero? n)
...              #f
...              (even? (- n 1))))
...      (even? x))
&gt;&gt;&gt; (hard-even? 22)
#t
</pre>
<p><strong>Predefined Functions.</strong>
There is a large collection of predefined functions, all bound to
names in the global environment, and we'll simply illustrate a few
here; the rest are catalogued in the <a class="reference external" href="http://people.csail.mit.edu/jaffer/r4rs_toc.html">Revised(4) Scheme</a> Report.
Function calls are not &quot;special&quot; in that they all use the same
completely uniform evaluation rule: recursively evaluate all items
(including the operator), and then apply the operator's value (which
must be a function) to the operands' values.</p>
<blockquote>
<ul>
<li><p class="first"><strong>Arithmetic:</strong>
Scheme provides the standard arithmetic operators, many with familiar
denotations, although the operators uniformly appear before the operands:</p>
<pre class="literal-block">
&gt;&gt;&gt; ; Semicolons introduce one-line comments.
&gt;&gt;&gt; ; Compute (3+7+10)*(1000-8) // 992 - 17
&gt;&gt;&gt; (- (quotient (* (+ 3 7 10) (- 1000 8))) 17)
3
&gt;&gt;&gt; (remainder 27 4)
3
&gt;&gt;&gt; (- 17)
-17
</pre>
<p>Similarly, there are the usual numeric comparison operators,
extended to allow more than two operands:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; (&lt; 0 5)
#t
&gt;&gt;&gt; (&gt;= 100 10 10 0)
#t
&gt;&gt;&gt; (= 21 (* 7 3) (+ 19 2))
#t
&gt;&gt;&gt; (not (= 15 14))
#t
&gt;&gt;&gt; (zero? (- 7 7))
#t
</pre>
</blockquote>
<p><tt class="docutils literal">not</tt>, by the way, is a function, not a special form
like <tt class="docutils literal">and</tt> or <tt class="docutils literal">or</tt>, because its operand must always be evaluated,
and so needs no special treatment.</p>
</li>
<li><p class="first"><strong>Lists and Pairs:</strong>
A large number of operations deal with pairs and lists (which again are built
of pairs and empty lists):</p>
<pre class="literal-block">
&gt;&gt;&gt; (cons 'a 'b)
(a . b)
&gt;&gt;&gt; (list 'a 'b)
(a b)
&gt;&gt;&gt; (cons 'a (cons 'b '()))
(a b)
&gt;&gt;&gt; (car (cons 'a 'b))
a
&gt;&gt;&gt; (cdr (cons 'a 'b))
b
&gt;&gt;&gt; (cdr (list a b))
(b)
&gt;&gt;&gt; (cadr '(a b))   ; An abbreviation for (car (cdr '(a b)))
b
&gt;&gt;&gt; (cddr '(a b))   ; Similarly, an abbreviation for (cdr (cdr '(a b)))
()
&gt;&gt;&gt; (list-tail '(a b c) 0)
(a b c)
&gt;&gt;&gt; (list-tail '(a b c) 1)
(b c)
&gt;&gt;&gt; (list-ref '(a b c) 0)
a
&gt;&gt;&gt; (list-ref '(a b c) 2)
c
&gt;&gt;&gt; (append '(a b) '(c d) '() '(e))
(a b c d e)
&gt;&gt;&gt; ; All but the last list is copied.  The last is shared, so:
&gt;&gt;&gt; (define L1 (list 'a 'b 'c))
&gt;&gt;&gt; (define L2 (list 'd))
&gt;&gt;&gt; (define L3 (append L1 L2))
&gt;&gt;&gt; (set-car! L1 1)
&gt;&gt;&gt; (set-car! L2 2)
&gt;&gt;&gt; L3
(a b c 2)
&gt;&gt;&gt; (null? '())
#t
&gt;&gt;&gt; (list? '())
#t
&gt;&gt;&gt; (list? '(a b))
#t
&gt;&gt;&gt; (list? '(a . b))
#f
</pre>
</li>
<li><p class="first"><strong>Equivalence:</strong>  The <tt class="docutils literal">=</tt> operation is for numbers.  For general
equality of values, Scheme distinguishes <tt class="docutils literal">eq?</tt> (like Python's
<tt class="docutils literal">is</tt>), <tt class="docutils literal">eqv?</tt> (similar, but is the same as <tt class="docutils literal">=</tt> on numbers),
and <tt class="docutils literal">equal?</tt> (compares list structures and strings for content).
Generally, we use <tt class="docutils literal">eqv?</tt> or <tt class="docutils literal">equal?</tt>, except in cases such as
comparing symbols, booleans, or the null list:</p>
<pre class="literal-block">
&gt;&gt;&gt; (eqv? 'a 'a)
#t
&gt;&gt;&gt; (eqv? 'a 'b)
#f
&gt;&gt;&gt; (eqv? 100 (+ 50 50))
#t
&gt;&gt;&gt; (eqv? (list 'a 'b) (list 'a 'b))
#f
&gt;&gt;&gt; (equal? (list 'a 'b) (list 'a 'b))
#t
</pre>
</li>
<li><p class="first"><strong>Types:</strong>
Each type of value satisfies exactly one of the basic type predicates:</p>
<pre class="literal-block">
&gt;&gt;&gt; (boolean? #f)
#t
&gt;&gt;&gt; (integer? 3)
#t
&gt;&gt;&gt; (pair? '(a b))
#t
&gt;&gt;&gt; (null? '())
#t
&gt;&gt;&gt; (symbol? 'a)
#t
&gt;&gt;&gt; (procedure? +)
#t
</pre>
</li>
<li><p class="first"><strong>Input and Output:</strong>
Scheme interpreters typically run a  read-eval-print loop, but one can
also output things under explicit control of the program, using the
same functions the interpreter does internally:</p>
<pre class="literal-block">
&gt;&gt;&gt; (begin (display 'a) (display 'b) (newline))
ab
</pre>
<p>Thus, <tt class="docutils literal">(display x)</tt> is somewhat akin to Python's</p>
<blockquote>
<div class="line-block">
<div class="line"><tt class="docutils literal">print(str(x), <span class="pre">end=&quot;&quot;)</span></tt></div>
</div>
</blockquote>
<p>and <tt class="docutils literal">(newline)</tt> is like <tt class="docutils literal">print()</tt>.</p>
<p>For input, the <tt class="docutils literal">(read)</tt> function reads a Scheme expression from the
current &quot;port&quot;.  It does <em>not</em> interpret the expression, but rather reads
it as data:</p>
<pre class="literal-block">
&gt;&gt;&gt; (read)
&gt;&gt;&gt; (a b c)
(a b c)
</pre>
</li>
<li><p class="first"><strong>Evaluation:</strong>
The <tt class="docutils literal">apply</tt> function provides direct access to the function-calling
operation:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; (apply cons '(1 2))
(1 . 2)
&gt;&gt;&gt; ;; Apply the function f to the arguments in L after g is
&gt;&gt;&gt; ;; applied to each of them
&gt;&gt;&gt; (define (compose-list f g L)
...     (apply f (map g L)))
&gt;&gt;&gt; (compose-list + (lambda (x) (* x x)) '(1 2 3))
14
</pre>
</blockquote>
<p>An extension allows for some &quot;fixed&quot; arguments at the beginning:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; (apply + 1 2 '(3 4 5))
15
</pre>
</blockquote>
<p>The following function is not in <a class="reference external" href="http://people.csail.mit.edu/jaffer/r4rs_toc.html">Revised(4) Scheme</a>, but is
present in our versions of the interpreter (<em>warning:</em> a non-standard
procedure that is not defined this way in later versions of Scheme):</p>
<pre class="literal-block">
&gt;&gt;&gt; (eval '(+ 1 2))
3
</pre>
<p>That is, <tt class="docutils literal">eval</tt> evaluates a piece of Scheme data that represents
a correct Scheme expression.  This version evaluates its expression
argument in the global environment.  Our interpreter also provides a
way to specify a specific environment for the evaluation:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; (define (incr n) (lambda (x) (+ n x)))
&gt;&gt;&gt; (define add5 (incr 5))
&gt;&gt;&gt; (add5 13)
18
&gt;&gt;&gt; (eval 'n (procedure-environment add5))
5
</pre>
</blockquote>
</li>
</ul>
</blockquote>
</div>
<div class="section" id="the-logo-language">
<span id="logo-language"></span><h2><a class="toc-backref" href="#id24">3.6.2&nbsp;&nbsp;&nbsp;The Logo Language</a></h2>
<p>Logo is another dialect of Lisp. It was designed for educational use, and
so many design decisions in Logo are meant to make the language more
comfortable for a beginner. For example, most Logo procedures are invoked in
prefix form (first the procedure name, then the arguments), but the common
arithmetic operators are also provided in the customary infix form. The
brilliance of Logo is that its simple, approachable syntax still provides
amazing expressivity for advanced programmers.</p>
<p>The central idea in Logo that accounts for its expressivity is that its
built-in container type, the Logo <tt class="docutils literal">sentence</tt> (also called a <tt class="docutils literal">list</tt>), can
easily store Logo source code!  Logo programs can write and interpret Logo
expressions as part of their evaluation process. Many dynamic languages support
code generation, including Python, but no language makes code generation quite
as fun and accessible as Logo.</p>
<p>You may want to download a fully implemented Logo interpreter at this point to
experiment with the language. The standard implementation is <a class="reference external" href="http://www.cs.berkeley.edu/~bh/logo.html">Berkeley Logo</a> (also known as UCBLogo), developed
by Brian Harvey and his Berkeley students. For macintosh uses, <a class="reference external" href="http://www.alancsmith.co.uk/logo/">ACSLogo</a> is compatible with the latest version of
Mac OSX and comes with a  <a class="reference external" href="http://www.alancsmith.co.uk/logo/LogoUserGuide151.pdf">user guide</a> that introduces many
features of the Logo language.</p>
<p><strong>Fundamentals.</strong> Logo is designed to be conversational.  The prompt of its
read-eval loop is a question mark (<tt class="docutils literal">?</tt>), evoking the question, &quot;what shall I
do next?&quot; A natural starting point is to ask Logo to <tt class="docutils literal">print</tt> a number:</p>
<pre class="literal-block">
? print 5
5
</pre>
<p>The Logo language employs an unusual call expression syntax that has no
delimiting punctuation at all.  Above, the argument <tt class="docutils literal">5</tt> is passed to
<tt class="docutils literal">print</tt>, which prints out its argument. The terminology used to describe the
programming constructs of Logo differs somewhat from that of Python.  Logo has
<em>procedures</em> rather than the equivalent &quot;functions&quot; in Python, and procedures
<em>output</em> values rather than &quot;returning&quot; them. The <tt class="docutils literal">print</tt> procedure always
outputs <tt class="docutils literal">None</tt>, but prints a string representation of its argument as a side
effect.  (Procedure arguments are typically called <em>inputs</em> in Logo, but we
will continue to call them arguments in this text for the sake of clarity.)</p>
<p>The most common data type in Logo is a <em>word</em>, a string without spaces. Words
serve as general-purpose values that can represent numbers, names, and boolean
values. Tokens that can be interpreted as numbers or boolean values, such as
<tt class="docutils literal">5</tt>, evaluate to words directly. On the other hand, names such as <tt class="docutils literal">five</tt>
are interpreted as procedure calls:</p>
<pre class="literal-block">
? 5
You do not say what to do with 5.
? five
I do not know how to five.
</pre>
<p>While <tt class="docutils literal">5</tt> and <tt class="docutils literal">five</tt> are interpreted differently, the Logo read-eval loop
complains either way.  The issue with the first case is that Logo complains
whenever a top-level expression it evaluates does not evaluate to <tt class="docutils literal">None</tt>.
Here, we see the first structural difference between the interpreters for Logo
and Calculator; the interface to the former is a read-eval loop that expects
the user to print results.  The latter employed a more typical read-eval-print
loop that printed return values automatically.  Python takes a hybrid approach:
only non-<tt class="docutils literal">None</tt> values are coerced to strings using <tt class="docutils literal">repr</tt> and then printed
automatically.</p>
<p>A line of Logo can contain multiple expressions in sequence. The interpreter
will evaluate each one in turn.  It will complain if any top-level expression
in a line does not evaluate to <tt class="docutils literal">None</tt>. Once an error occurs, the rest of the
line is ignored:</p>
<pre class="literal-block">
? print 1 print 2
1
2
? 3 print 4
You do not say what to do with 3.
</pre>
<p>Logo call expressions can be nested. In the version of Logo we will implement,
each procedure takes a fixed number of arguments. Therefore, the Logo
interpreter is able to determine uniquely when the operands of a nested call
expression are complete.  Consider, for instance, two procedures <tt class="docutils literal">sum</tt> and
<tt class="docutils literal">difference</tt> that output the sum and difference of their two arguments,
respectively:</p>
<pre class="literal-block">
? print sum 10 difference 7 3
14
</pre>
<p>We can see from this nesting example that the parentheses and commas that
delimit call expressions are not strictly necessary. In the Calculator
interpreter, punctuation allowed us to build expression trees as a purely
syntactic operation; without ever consulting the meaning of the operator names.
In Logo, we must use our knowledge of how many arguments each procedure takes
in order to discover the correct structure of a nested expression. This issue
is addressed in further detail in the next section.</p>
<p>Logo also supports infix operators, such as <tt class="docutils literal">+</tt> and <tt class="docutils literal">*</tt>. The precedence of
these operators is resolved according to the standard rules of algebra;
multiplication and division take precedence over addition and subtraction:</p>
<pre class="literal-block">
? 2 + 3 * 4
14
</pre>
<p>The details of how to implement operator precedence and infix operators to
form correct expression trees is left as an exercise. For the following
discussion, we will concentrate on call expressions using prefix syntax.</p>
<p><strong>Quotation.</strong> A bare name is interpreted as the beginning of a call
expression, but we would also like to reference words as data. A token that
begins with a double quote is interpreted as a word literal. Note that word
literals do not have a trailing quotation mark in Logo:</p>
<pre class="literal-block">
? print &quot;hello
hello
</pre>
<p>In dialects of Lisp (and Logo is such a dialect), any expression that is not
evaluated is said to be <em>quoted</em>. This notion of quotation is derived from a
classic philosophical distinction between a thing, such as a dog, which runs
around and barks, and the word &quot;dog&quot; that is a linguistic construct for
designating such things. When we use &quot;dog&quot; in quotation marks, we do not refer
to some dog in particular but instead to a word. In language, quotation allow
us to talk about language itself, and so it is in Logo. We can refer to the
procedure for <tt class="docutils literal">sum</tt> by name without actually applying it by quoting it:</p>
<pre class="literal-block">
? print &quot;sum
sum
</pre>
<p>In addition to words, Logo includes the <em>sentence</em> type, interchangeably called
a list. Sentences are enclosed in square brackets. The <tt class="docutils literal">print</tt> procedure does
not show brackets to preserve the conversational style of Logo, but the square
brackets can be printed in the output by using the <tt class="docutils literal">show</tt> procedure:</p>
<pre class="literal-block">
? print [hello world]
hello world
? show [hello world]
[hello world]
</pre>
<p>Sentences can be constructed using three different two-argument procedures. The
<tt class="docutils literal">sentence</tt> procedure combines its arguments into a sentence. It is
polymorphic; it places its arguments into a new sentence if they are words or
concatenates its arguments if they are sentences.  The result is always a
sentence:</p>
<pre class="literal-block">
? show sentence 1 2
[1 2]
? show sentence 1 [2 3]
[1 2 3]
? show sentence [1 2] 3
[1 2 3]
? show sentence [1 2] [3 4]
[1 2 3 4]
</pre>
<p>The <tt class="docutils literal">list</tt> procedure creates a sentence from two elements, which allows the
user to create hierarchical data structures:</p>
<pre class="literal-block">
? show list 1 2
[1 2]
? show list 1 [2 3]
[1 [2 3]]
? show list [1 2] 3
[[1 2] 3]
? show list [1 2] [3 4]
[[1 2] [3 4]]
</pre>
<p>Finally, the <tt class="docutils literal">fput</tt> procedure creates a list from a first element and the
rest of the list, as did the <tt class="docutils literal">Rlist</tt> Python constructor from earlier in the
chapter:</p>
<pre class="literal-block">
? show fput 1 [2 3]
[1 2 3]
? show fput [1 2] [3 4]
[[1 2] 3 4]
</pre>
<p>Collectively, we can call <tt class="docutils literal">sentence</tt>, <tt class="docutils literal">list</tt>, and <tt class="docutils literal">fput</tt> the <em>sentence
constructors</em> in Logo.  Deconstructing a sentence into its <tt class="docutils literal">first</tt>, <tt class="docutils literal">last</tt>,
and rest (called <tt class="docutils literal">butfirst</tt>) in Logo is straightforward as well. Hence, we
also have a set of selector procedures for sentences:</p>
<pre class="literal-block">
? print first [1 2 3]
1
? print last [1 2 3]
3
? print butfirst [1 2 3]
[2 3]
</pre>
<p><strong>Expressions as Data.</strong> The contents of a sentence is also quoted in the sense
that it is not evaluated. Hence, we can print Logo expressions without
evaluating them:</p>
<pre class="literal-block">
? show [print sum 1 2]
[print sum 1 2]
</pre>
<p>The purpose of representing Logo expressions as sentences is typically not to
print them out, but instead to evaluate them using the <tt class="docutils literal">run</tt> procedure:</p>
<pre class="literal-block">
? run [print sum 1 2]
3
</pre>
<p>Combining quotation, sentence constructors, and the <tt class="docutils literal">run</tt> procedure, we
arrive at a very general means of combination that builds Logo expressions on
the fly and then evaluates them:</p>
<pre class="literal-block">
? run sentence &quot;print [sum 1 2]
3
? print run sentence &quot;sum sentence 10 run [difference 7 3]
14
</pre>
<p>The point of this last example is to show that while the procedures <tt class="docutils literal">sum</tt> and
<tt class="docutils literal">difference</tt> are not first-class constructs in Logo (they cannot be placed in
a sentence, for instance), their quoted names are first-class, and the <tt class="docutils literal">run</tt>
procedure can resolve those names to the procedures to which they refer.</p>
<p>The ability to represent code as data and later interpret it as part of the
program is a defining feature of Lisp-style languages. The idea that a program
can rewrite itself as it executes is a powerful one, and served as the
foundation for early research in artificial intelligence (AI). Lisp was the
preferred language of AI researchers for decades. <a class="reference external" href="http://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf">The Lisp language</a>
was invented by John McCarthy, who coined the term &quot;artificial intelligence&quot;
and played a critical role in defining the field.  This code-as-data property
of Lisp dialects, along with their simplicity and elegance, continues to
attract new Lisp programmers today.</p>
<p><strong>Turtle graphics.</strong> No implementation of Logo is complete without graphical
output based on the Logo turtle. This turtle begins in the center of a canvas,
moves and turns based on procedures, and draws lines behind it as it moves.
While the turtle was invented to engage children in the act of programming, it
remains an entertaining graphical tool for even advanced programmers.</p>
<p>At any moment during the course of executing a Logo program, the Logo turtle
has a position and heading on the canvas. Single-argument procedures such as
<tt class="docutils literal">forward</tt> and <tt class="docutils literal">right</tt> change the position and heading of the turtle. Common
procedures have abbreviations: <tt class="docutils literal">forward</tt> can also be called as <tt class="docutils literal">fd</tt>, etc.
The nested expression below draws a star with a smaller star at each vertex:</p>
<pre class="literal-block">
? repeat 5 [fd 100 repeat 5 [fd 20 rt 144] rt 144]
</pre>
<div class="figure">
<img alt="img/star.png" src="img/star.png" />
</div>
<p>The full repertoire of Turtle procedures is also built into Python as the
<a class="reference external" href="http://docs.python.org/py3k/library/turtle.html">turtle library module</a>. A
limited subset of these functions are exposed as Logo procedures in the
companion project to this chapter.</p>
<p><strong>Assignment.</strong> Logo supports binding names to values. As in Python, a Logo
environment consists of a sequence of frames, and each frame can have
at most one value bound to a given name. In Logo, names are bound with the
<tt class="docutils literal">make</tt> procedure, which takes as arguments a name and a value:</p>
<pre class="literal-block">
? make &quot;x 2
</pre>
<p>The first argument is the name <tt class="docutils literal">x</tt>, rather than the output of applying the
procedure <tt class="docutils literal">x</tt>, and so it must be quoted. The values bound to names are
retrieved by evaluating expressions that begin with a colon:</p>
<pre class="literal-block">
? print :x
2
</pre>
<p>Any word that begins with a colon, such as <tt class="docutils literal">:x</tt>, is called a variable.  A
variable evaluates to the value to which the name of the variable is bound in
the current environment.</p>
<p>The <tt class="docutils literal">make</tt> procedure does not have the same effect as an assignment statement
in Python. The name passed to <tt class="docutils literal">make</tt> is either already bound to a value or is
currently unbound.</p>
<ol class="arabic simple">
<li>If the name is already bound, <tt class="docutils literal">make</tt> re-binds that name in the first frame
in which it is found.</li>
<li>If the name is not bound, <tt class="docutils literal">make</tt> binds the name in the global frame.</li>
</ol>
<p>This behavior contrasts sharply with the semantics of the Python assignment
statement, which always binds a name to a value in the first frame of the
current environment. The first assignment rule above is similar to Python
assignment following a <tt class="docutils literal">nonlocal</tt> statement.  The second is similar to Python
assignment following a <tt class="docutils literal">global</tt> statement.</p>
<p><strong>Procedures.</strong> Logo supports user-defined procedures using definitions that
begin with the <tt class="docutils literal">to</tt> keyword. Definitions are the final type of expression in
Logo, along with call expressions, primitive expressions, and quoted
expressions. The first line of a definition gives the name of the new
procedure, followed by the formal parameters as variables. The lines that
follow constitute the body of the procedure, which can span multiple lines and
must end with a line that contains only the token <tt class="docutils literal">end</tt>.  The Logo read-eval
loop prompts the user for procedure bodies with a <tt class="docutils literal">&gt;</tt> continuation symbol.
Values are output from a user-defined procedure using the <tt class="docutils literal">output</tt>
procedure:</p>
<pre class="literal-block">
? to double :x
&gt; output sum :x :x
&gt; end
? print double 4
8
</pre>
<p>Logo's application process for a user-defined procedure is similar to the
process in Python. Applying a procedure to a sequence of arguments begins by
extending an environment with a new frame, binding the formal parameters of the
procedure to the argument values, and then evaluating the lines of the body of
the procedure in the environment that starts with that new frame.</p>
<p>A call to <tt class="docutils literal">output</tt> has the same role in Logo as a <tt class="docutils literal">return</tt> statement in
Python: it halts the execution of the body of a procedure and returns a value.
A Logo procedure can return no value at all by calling <tt class="docutils literal">stop</tt>:</p>
<pre class="literal-block">
? to count
&gt; print 1
&gt; print 2
&gt; stop
&gt; print 3
&gt; end
? count
1
2
</pre>
<p><strong>Scope.</strong> Logo is a <em>dynamically scoped</em> language. A lexically scoped language
such as Python does not allow the local names of one function to affect the
evaluation of another function unless the second function was explicitly
defined within the first.  The formal parameters of two top-level functions are
completely isolated. In a dynamically scoped language, there is no such
isolation. When one function calls another function, the names bound in the
local frame for the first are accessible in the body of the second:</p>
<pre class="literal-block">
? to print_last_x
&gt; print :x
&gt; end
? to print_x :x
&gt; print_last_x
&gt; end
? print_x 5
5
</pre>
<p>While the name <tt class="docutils literal">x</tt> is not bound in the global frame, it is bound in the local
frame for <tt class="docutils literal">print_x</tt>, the function that is called first. Logo's dynamic
scoping rules allow the function <tt class="docutils literal">print_last_x</tt> to refer to <tt class="docutils literal">x</tt>, which was
bound as the formal parameter of <tt class="docutils literal">print_x</tt>.</p>
<p>Dynamic scoping is implemented by a single change to the environment model of
computation.  The frame that is created by calling a user-defined function
always extends the current environment. For example, the call to <tt class="docutils literal">print_x</tt>
above introduces a new frame that extends the current environment, which
consists solely of the global frame. Within the body of <tt class="docutils literal">print_x</tt>, the call to
<tt class="docutils literal">print_last_x</tt> introduces another frame that extends the current environment,
which includes both the local frame for <tt class="docutils literal">print_x</tt> and the global frame. As a
result, looking up the name <tt class="docutils literal">x</tt> in the body of <tt class="docutils literal">print_last_x</tt> finds that
name bound to <tt class="docutils literal">5</tt> in the local frame for <tt class="docutils literal">print_x</tt>. Alternatively, under
the lexical scoping rules of Python, the frame for <tt class="docutils literal">print_last_x</tt> would have
extended only the global frame and not the local frame for <tt class="docutils literal">print_x</tt>.</p>
<p>A dynamically scoped language has the advantage that its procedures may not
need to take as many arguments. For instance, the <tt class="docutils literal">print_last_x</tt> procedure
above takes no arguments, and yet its behavior can be parameterized by an
enclosing scope.</p>
<p><strong>General programming.</strong> Our tour of Logo is complete, and yet we have not
introduced any advanced features, such as an object system, higher-order
procedures, or even statements. Learning to program effectively in Logo
requires piecing together the simple features of the language into effective
combinations.</p>
<p>There is no conditional expression type in Logo; the procedures <tt class="docutils literal">if</tt> and
<tt class="docutils literal">ifelse</tt> are applied using call expression evaluation rules. The first
argument of <tt class="docutils literal">if</tt> is a boolean word, either <tt class="docutils literal">True</tt> or <tt class="docutils literal">False</tt>. The second
argument is not an output value, but instead a sentence that contains the line
of Logo code to be evaluated if the first argument is <tt class="docutils literal">True</tt>. An important
consequence of this design is that the contents of the second argument is not
evaluated at all unless it will be used:</p>
<pre class="literal-block">
? 1/0
div raised a ZeroDivisionError: division by zero
? to reciprocal :x
&gt; if not :x = 0 [output 1 / :x]
&gt; output &quot;infinity
&gt; end
? print reciprocal 2
0.5
? print reciprocal 0
infinity
</pre>
<p>Not only does the Logo conditional expression not require a special syntax, but
it can in fact be implemented in terms of <tt class="docutils literal">word</tt> and <tt class="docutils literal">run</tt>. The primitive
procedure <tt class="docutils literal">ifelse</tt> takes three arguments: a boolean word, a sentence to be
evaluated if that word is <tt class="docutils literal">True</tt>, and a sentence to be evaluated if that word
is <tt class="docutils literal">False</tt>. By clever naming of the formal parameters, we can implement a
user-defined procedure <tt class="docutils literal">ifelse2</tt> with the same behavior:</p>
<pre class="literal-block">
? to ifelse2 :predicate :True :False
&gt; output run run word &quot;: :predicate
&gt; end
? print ifelse2 emptyp [] [&quot;empty] [&quot;full]
empty
</pre>
<p>Recursive procedures do not require any special syntax, and they can be used
with <tt class="docutils literal">run</tt>, <tt class="docutils literal">sentence</tt>, <tt class="docutils literal">first</tt>, and <tt class="docutils literal">butfirst</tt> to define general
sequence operations on sentences. For instance, we can apply a procedure to an
argument by building a two-element sentence and running it.  The argument must
be quoted if it is a word:</p>
<pre class="literal-block">
? to apply_fn :fn :arg
&gt; output run list :fn ifelse word? :arg [word &quot;&quot; :arg] [:arg]
&gt; end
</pre>
<p>Next, we can define a procedure for mapping a procedure <tt class="docutils literal">:fn</tt> over the words
in a sentence <tt class="docutils literal">:s</tt> incrementally:</p>
<pre class="literal-block">
? to map_fn :fn :s
&gt; if emptyp :s [output []]
&gt; output fput apply_fn :fn first :s map_fn :fn butfirst :s
&gt; end
? show map &quot;double [1 2 3]
[2 4 6]
</pre>
<p>The second line of the body of <tt class="docutils literal">map_fn</tt> can also be written with parentheses
to indicate the nested structure of the call expression. However, parentheses
show where call expressions begin and end, rather than surrounding only the
operands and not the operator:</p>
<pre class="literal-block">
&gt; (output (fput (apply_fn :fn (first :s)) (map_fn :fn (butfirst :s))))
</pre>
<p>Parentheses are not necessary in Logo, but they often assist programmers in
documenting the structure of nested expressions. Most dialects of Lisp require
parentheses and therefore have a syntax with explicit nesting.</p>
<p>As a final example, Logo can express recursive drawings using its turtle
graphics in a remarkably compact form.  Sierpinski's triangle is a fractal that
draws each triangle as three neighboring triangles that have vertexes at the
midpoints of the legs of the triangle that contains them.  It can be drawn to a
finite recursive depth by this Logo program:</p>
<pre class="literal-block">
? to triangle :exp
&gt; repeat 3 [run :exp lt 120]
&gt; end

? to sierpinski :d :k
&gt; triangle [ifelse :k = 1 [fd :d] [leg :d :k]]
&gt; end

? to leg :d :k
&gt; sierpinski :d / 2 :k - 1
&gt; penup fd :d pendown
&gt; end
</pre>
<p>The <tt class="docutils literal">triangle</tt> procedure is a general method for repeating a drawing
procedure three times with a left turn following each repetition.  The
<tt class="docutils literal">sierpinski</tt> procedure takes a length and a recursive depth.  It draws a
plain triangle if the depth is <tt class="docutils literal">1</tt>, and otherwise draws a triangle made up of
calls to <tt class="docutils literal">leg</tt>.  The <tt class="docutils literal">leg</tt> procedure draws a single leg of a recursive
Sierpinski triangle by a recursive call to <tt class="docutils literal">sierpinski</tt> that fills the first
half of the length of the leg, then by moving the turtle to the next vertex.
The procedures <tt class="docutils literal">up</tt> and <tt class="docutils literal">down</tt> stop the turtle from drawing as it moves by
lifting its pen up and the placing it down again. The mutual recursion between
<tt class="docutils literal">sierpinski</tt> and <tt class="docutils literal">leg</tt> yields this result:</p>
<pre class="literal-block">
? sierpinski 400 6
</pre>
<div class="figure">
<img alt="img/sier.png" src="img/sier.png" />
</div>
</div>
<div class="section" id="structure">
<h2><a class="toc-backref" href="#id25">3.6.3&nbsp;&nbsp;&nbsp;Structure</a></h2>
<p>This section describes the general structure of a Logo interpreter. While this
chapter is self-contained, it does reference the companion project.  Completing
that project will produce a working implementation of the interpreter sketch
described here.</p>
<p>An interpreter for Logo can share much of the same structure as the Calculator
interpreter.  A parser produces an expression data structure that is
interpreted by an evaluator. The evaluation function inspects the form of an
expression, and for call expressions it calls a function to apply a procedure
to some arguments. However, there are structural differences that accommodate
Logo's unusual syntax.</p>
<p><strong>Lines.</strong> The Logo parser does not read a single expression, but instead
reads a full line of code that may contain multiple expressions in sequence.
Rather than returning an expression tree, it returns a Logo sentence.</p>
<p>The parser actually does very little syntactic analysis.  In particular,
parsing does not differentiate the operator and operand subexpressions of call
expressions into different branches of a tree. Instead, the components of a
call expression are listed in sequence, and nested call expressions are
represented as a flat sequence of tokens. Finally, parsing does not determine
the type of even primitive expressions such as numbers because Logo does not
have a rich type system; instead, every element is a word or a sentence.</p>
<pre class="doctest-block">
&gt;&gt;&gt; parse_line('print sum 10 difference 7 3')
['print', 'sum', '10', 'difference', '7', '3']
</pre>
<p>The parser performs so little analysis because the dynamic character of Logo
requires that the evaluator resolve the structure of nested expressions.</p>
<p>The parser does identify the nested structure of sentences. Sentences within
sentences are represented as nested Python lists.</p>
<pre class="doctest-block">
&gt;&gt;&gt; parse_line('print sentence &quot;this [is a [deep] list]')
['print', 'sentence', '&quot;this', ['is', 'a', ['deep'], 'list']]
</pre>
<p>A complete implementation of <tt class="docutils literal">parse_line</tt> appears in the companion projects
as <tt class="docutils literal">logo_parser.py</tt>.</p>
<p><strong>Evaluation.</strong> Logo is evaluated one line at a time. A skeleton implementation
of the evaluator is defined in <tt class="docutils literal">logo.py</tt> of the companion project. The
sentence returned from <tt class="docutils literal">parse_line</tt> is passed to the <tt class="docutils literal">eval_line</tt> function,
which evaluates each expression in the line. The <tt class="docutils literal">eval_line</tt> function
repeatedly calls <tt class="docutils literal">logo_eval</tt>, which evaluates the next full expression in the
line until the line has been evaluated completely, then returns the last value.
The <tt class="docutils literal">logo_eval</tt> function evaluates a single expression.</p>
<div class="figure">
<img alt="img/logo_eval.png" src="img/logo_eval.png" />
</div>
<p>The <tt class="docutils literal">logo_eval</tt> function evaluates the different forms of expressions that
we introduced in the last section: primitives, variables, definitions,
quoted expressions, and call expressions. The form of a multi-element
expression in Logo can be determined by inspecting its first element.  Each form
of expression as its own evaluation rule.</p>
<ol class="arabic simple">
<li>A primitive expression (a word that can be interpreted as a number,
<tt class="docutils literal">True</tt>, or <tt class="docutils literal">False</tt>) evaluates to itself.</li>
<li>A variable is looked up in the environment.  Environments are discussed in
detail in the next section.</li>
<li>A definition is handled as a special case. User-defined procedures are also
discussed in the next section.</li>
<li>A quoted expression evaluates to the text of the quotation, which is a
string without the preceding quote.  Sentences (represented as Python lists)
are also considered to be quoted; they evaluate to themselves.</li>
<li>A call expression looks up the operator name in the current environment and
applies the procedure that is bound to that name.</li>
</ol>
<p>A simplified implementation of <tt class="docutils literal">logo_apply</tt> appears below. Some error
checking has been removed in order to focus our discussion. A more robust
implementation appears in the companion project.</p>
<pre class="doctest-block">
&gt;&gt;&gt; def logo_eval(line, env):
        &quot;&quot;&quot;Evaluate the first expression in a line.&quot;&quot;&quot;
        token = line.pop()
        if isprimitive(token):
            return token
        elif isvariable(token):
            return env.lookup_variable(variable_name(token))
        elif isdefinition(token):
            return eval_definition(line, env)
        elif isquoted(token):
            return text_of_quotation(token)
        else:
            procedure = env.procedures.get(token, None)
            return apply_procedure(procedure, line, env)
</pre>
<p>The final case above invokes a second process, procedure application, that is
expressed by a function <tt class="docutils literal">apply_procedure</tt>. To apply a procedure named by an
operator token, that operator is looked up in the current environment.  In the
definition above, <tt class="docutils literal">env</tt> is an instance of the <tt class="docutils literal">Environment</tt> class described
in the next section.  The attribute <tt class="docutils literal">env.procedures</tt> is a dictionary that
stores the mapping between operator names and procedures. In Logo, an
environment has a single such mapping; there are no locally defined procedures.
Moreover, Logo maintains separate mappings, called separate <em>namespaces</em>, for
the the names of procedures and the names of variables.  A procedure and an
unrelated variable can have the same name in Logo. However, reusing names in
this way is not recommended.</p>
<p><strong>Procedure application.</strong> Procedure application begins by calling the
<tt class="docutils literal">apply_procedure</tt> function, which is passed the procedure looked up by
<tt class="docutils literal">logo_apply</tt>, along with the remainder of the current line of code and
the current environment. The procedure application process in Logo is
considerably more general than the <tt class="docutils literal">calc_apply</tt> function in Calculator. In
particular, <tt class="docutils literal">apply_procedure</tt> must inspect the procedure it is meant to apply
in order to determine its argument count <em>n</em>, before evaluating <em>n</em> operand
expressions. It is here that we see why the Logo parser was unable to build an
expression tree by syntactic analysis alone; the structure of the tree is
determined by the procedure.</p>
<p>The <tt class="docutils literal">apply_procedure</tt> function calls a function <tt class="docutils literal">collect_args</tt> that must
repeatedly call <tt class="docutils literal">logo_eval</tt> to evaluate the next <em>n</em> expressions on the line.
Then, having computed the arguments to the procedure, <tt class="docutils literal">apply_procedure</tt> calls
<tt class="docutils literal">logo_apply</tt>, the function that actually applies procedures to arguments.
The call graph below illustrates the process.</p>
<div class="figure">
<img alt="img/logo_apply.png" src="img/logo_apply.png" />
</div>
<p>The final function <tt class="docutils literal">logo_apply</tt> applies two kinds of arguments: primitive
procedures and user-defined procedures, both of which are instances of the
<tt class="docutils literal">Procedure</tt> class. A <tt class="docutils literal">Procedure</tt> is a Python object that has instance
attributes for the name, argument count, body, and formal parameters of a
procedure. The type of the <tt class="docutils literal">body</tt> attribute varies. A primitive procedure is
implemented in Python, and so its <tt class="docutils literal">body</tt> is a Python function.  A
user-defined (non-primitive) procedure is defined in Logo, and so its <tt class="docutils literal">body</tt>
is a list of lines of Logo code. A <tt class="docutils literal">Procedure</tt> also has two boolean-valued
attributes, one to indicated whether it is primitive and another to indicate
whether it needs access to the current environment.</p>
<pre class="doctest-block">
&gt;&gt;&gt; class Procedure():
        def __init__(self, name, arg_count, body, isprimitive=False,
                     needs_env=False, formal_params=None):
            self.name = name
            self.arg_count = arg_count
            self.body = body
            self.isprimitive = isprimitive
            self.needs_env = needs_env
            self.formal_params = formal_params
</pre>
<p>A primitive procedure is applied by calling its body on the argument list and
returning its return value as the output of the procedure.</p>
<pre class="doctest-block">
&gt;&gt;&gt; def logo_apply(proc, args):
        &quot;&quot;&quot;Apply a Logo procedure to a list of arguments.&quot;&quot;&quot;
        if proc.isprimitive:
            return proc.body(*args)
        else:
            &quot;&quot;&quot;Apply a user-defined procedure&quot;&quot;&quot;
</pre>
<p>The body of a user-defined procedure is a list of lines, each of which is a
Logo sentence. To apply the procedure to a list of arguments, we evaluate the
lines of the body in a new environment.  To construct this environment, a new
frame is added to the environment in which the formal parameters of the
procedure are bound to the arguments.  The important structural aspect of this
process is that evaluating a line of the body of a user-defined procedure
requires a recursive call to <tt class="docutils literal">eval_line</tt>.</p>
<p><strong>Eval/apply recursion.</strong> The functions that implement the evaluation process,
<tt class="docutils literal">eval_line</tt> and <tt class="docutils literal">logo_eval</tt>, and the functions that implement the function
application process, <tt class="docutils literal">apply_procedure</tt>, <tt class="docutils literal">collect_args</tt>, and <tt class="docutils literal">logo_apply</tt>,
are mutually recursive. Evaluation requires application whenever a call
expression is found.  Application uses evaluation to evaluate operand
expressions into arguments, as well as to evaluate the body of user-defined
procedures. The general structure of this mutually recursive process appears in
interpreters quite generally: evaluation is defined in terms of application and
application is defined in terms of evaluation.</p>
<div class="figure">
<img alt="img/eval_apply.png" src="img/eval_apply.png" />
</div>
<p>This recursive cycle ends with language primitives. Evaluation has a base case
that is evaluating a primitive expression, variable, quoted expression, or
definition. Function application has a base case that is applying a primitive
procedure. This mutually recursive structure, between an eval function that
processes expression forms and an apply function that processes functions and
their arguments, constitutes the essence of the evaluation process.</p>
</div>
<div class="section" id="environments">
<h2><a class="toc-backref" href="#id26">3.6.4&nbsp;&nbsp;&nbsp;Environments</a></h2>
<p>Now that we have described the structure of our Logo interpreter, we turn to
implementing the <tt class="docutils literal">Environment</tt> class so that it correctly supports
assignment, procedure definition, and variable lookup with dynamic scope. An
<tt class="docutils literal">Environment</tt> instance represents the collective set of name bindings that
are accessible at some point in the course of program execution. Bindings are
organized into frames, and frames are implemented as Python dictionaries.
Frames contain name bindings for variables, but not procedures; the bindings
between operator names and <tt class="docutils literal">Procedure</tt> instances are stored separately in
Logo. In the project implementation, frames that contain variable name bindings
are stored as a list of dictionaries in the <tt class="docutils literal">_frames</tt> attribute of an
<tt class="docutils literal">Environment</tt>, while procedure name bindings are stored in the
dictionary-valued <tt class="docutils literal">procedures</tt> attribute.</p>
<p>Frames are not accessed directly, but instead through two <tt class="docutils literal">Environment</tt>
methods: <tt class="docutils literal">lookup_variable</tt> and <tt class="docutils literal">set_variable_value</tt>. The first implements a
process identical to the look-up procedure that we introduced in the
environment model of computation in Chapter 1. A name is matched against the
bindings of the first (most recently added) frame of the current environment.
If it is found, the value to which it is bound is returned. If it is not found,
look-up proceeds to the frame that was extended by the current frame.</p>
<p>The <tt class="docutils literal">set_variable_value</tt> method also searches for a binding that matches a
variable name. If one is found, it is updated with a new value.  If none is
found, then a new binding is created in the global frame.  The implementations
of these methods are left as an exercise in the companion project.</p>
<p>The <tt class="docutils literal">lookup_variable</tt> method is invoked from <tt class="docutils literal">logo_eval</tt> when evaluating a
variable name. The <tt class="docutils literal">set_variable_value</tt> method is invoked by the
<tt class="docutils literal">logo_make</tt> function, which serves as the body of the primitive <tt class="docutils literal">make</tt>
procedure in Logo.</p>
<pre class="doctest-block">
&gt;&gt;&gt; def logo_make(symbol, val, env):
        &quot;&quot;&quot;Apply the Logo make primitive, which binds a name to a value.&quot;&quot;&quot;
        env.set_variable_value(symbol, val)
</pre>
<p>With the addition of variables and the <tt class="docutils literal">make</tt> primitive, our interpreter
supports its first means of abstraction: binding names to values. In Logo, we
can now replicate our first abstraction steps in Python from Chapter 1:</p>
<pre class="literal-block">
? make &quot;radius 10
? print 2 * :radius
20
</pre>
<p>Assignment is only a limited form of abstraction. We have seen from the
beginning of this course that user-defined functions are a critical tool in
managing the complexity of even moderately sized programs.  Two enhancements
will enable user-defined procedures in Logo. First, we must describe the
implementation of <tt class="docutils literal">eval_definition</tt>, the Python function called from
<tt class="docutils literal">logo_eval</tt> when the current line is a definition. Second, we will complete
our description of the process in <tt class="docutils literal">logo_apply</tt> that applies a user-defined
procedure to some arguments.  Both of these changes leverage the <tt class="docutils literal">Procedure</tt>
class defined in the previous section.</p>
<p>A definition is evaluated by creating a new <tt class="docutils literal">Procedure</tt> instance that
represents the user-defined procedure. Consider the following Logo procedure
definition:</p>
<pre class="literal-block">
? to factorial :n
&gt; output ifelse :n = 1 [1] [:n * factorial :n - 1]
&gt; end
? print fact 5
120
</pre>
<p>The first line of the definition supplies the name <tt class="docutils literal">factorial</tt> and formal
parameter <tt class="docutils literal">n</tt> of the procedure. The line that follows constitute the
body of the procedure.  This line is not evaluated immediately, but instead
stored for future application. That is, the line is read and parsed by
<tt class="docutils literal">eval_definition</tt>, but not passed to <tt class="docutils literal">eval_line</tt>. Lines of the body are
read from the user until a line containing only <tt class="docutils literal">end</tt> is encountered. In Logo,
<tt class="docutils literal">end</tt> is not a procedure to be evaluated, nor is it part of the procedure
body; it is a syntactic marker of the end of a procedure definition.</p>
<p>The <tt class="docutils literal">Procedure</tt> instance created from this procedure name, formal parameter
list, and body, is registered in the <tt class="docutils literal">procedures</tt> dictionary attribute of the
environment. In Logo, unlike Python, once a procedure is bound to a name, no
other definition can use that name again.</p>
<p>The <tt class="docutils literal">logo_apply</tt> function applies a <tt class="docutils literal">Procedure</tt> instance to some arguments,
which are Logo values represented as strings (for words) and lists (for
sentences). For a user-defined procedure, <tt class="docutils literal">logo_apply</tt> creates a new frame,
a dictionary object in which the the keys are the formal parameters of the
procedure and the values are the arguments. In a dynamically scoped language
such as Logo, this new frame always extends the current environment in which
the procedure was called. Therefore, we append the newly created frame onto
the current environment. Then, each line of the body is passed to <tt class="docutils literal">eval_line</tt>
in turn. Finally, we can remove the newly created frame from the environment
after evaluating its body.  Because Logo does not support higher-order or
first-class procedures, we never need to track more than one environment at a
time throughout the course of execution of a program.</p>
<p>The following example illustrates the list of frames and dynamic scoping rules
that result from applying these two user-defined Logo procedures:</p>
<pre class="literal-block">
? to f :x
&gt; make &quot;z sum :x :y
&gt; end
? to g :x :y
&gt; f sum :x :x
&gt; end
? g 3 7
? print :z
13
</pre>
<p>The environment created from the evaluation of these expressions is divided
between procedures and frames, which are maintained in separate name spaces.
The order of frames is determined by the order of calls.</p>
<div class="figure">
<img alt="img/scope.png" src="img/scope.png" />
</div>
</div>
<div class="section" id="data-as-programs">
<h2><a class="toc-backref" href="#id27">3.6.5&nbsp;&nbsp;&nbsp;Data as Programs</a></h2>
<p>In thinking about a program that evaluates Logo expressions, an analogy
might be helpful. One operational view of the meaning of a program is that a
program is a description of an abstract machine. For example, consider again
this procedure to compute factorials:</p>
<pre class="literal-block">
? to factorial :n
&gt; output ifelse :n = 1 [1] [:n * factorial :n - 1]
&gt; end
</pre>
<p>We could express an equivalent program in Python as well, using a conditional
expression.</p>
<pre class="doctest-block">
&gt;&gt;&gt; def factorial(n):
        return 1 if n == 1 else n * factorial(n - 1)
</pre>
<p>We may regard this program as the description of a machine containing parts
that decrement, multiply, and test for equality, together with a two-position
switch and another factorial machine. (The factorial machine is infinite
because it contains another factorial machine within it.) The figure below is a
flow diagram for the factorial machine, showing how the parts are wired
together.</p>
<div class="figure">
<img alt="img/factorial_machine.png" src="img/factorial_machine.png" />
</div>
<p>In a similar way, we can regard the Logo interpreter as a very special machine
that takes as input a description of a machine. Given this input, the
interpreter configures itself to emulate the machine described. For example, if
we feed our evaluator the definition of factorial the evaluator will be able to
compute factorials.</p>
<div class="figure">
<img alt="img/universal_machine.png" src="img/universal_machine.png" />
</div>
<p>From this perspective, our Logo interpreter is seen to be a universal machine.
It mimics other machines when these are described as Logo programs.
It acts as a bridge between the data objects that are manipulated by our
programming language and the programming language itself. Image that a user
types a Logo expression into our running Logo interpreter. From the perspective
of the user, an input expression such as <tt class="docutils literal">sum 2 2</tt> is an expression in the
programming language, which the interpreter should evaluate. From the perspective
of the Logo interpreter, however, the expression is simply a sentence of words
that is to be manipulated according to a well-defined set of rules.</p>
<p>That the user's programs are the interpreter's data need not be a source of
confusion. In fact, it is sometimes convenient to ignore this distinction, and
to give the user the ability to explicitly evaluate a data object as an
expression. In Logo, we use this facility whenever employing the <tt class="docutils literal">run</tt>
procedure.  Similar functions exist in Python: the <tt class="docutils literal">eval</tt> function will
evaluate a Python expression and the <tt class="docutils literal">exec</tt> function will execute a Python
statement. Thus,</p>
<pre class="doctest-block">
&gt;&gt;&gt; eval('2+2')
4
</pre>
<p>and</p>
<pre class="doctest-block">
&gt;&gt;&gt; 2+2
4
</pre>
<p>both return the same result. Evaluating expressions that are constructed as a
part of execution is a common and powerful feature in dynamic programming
languages. In few languages is this practice as common as in Logo, but the
ability to construct and evaluate expressions during the course of execution of
a program can prove to be a valuable tool for any programmer.</p>
</div>
</div>
</div>
</body>
</html>
